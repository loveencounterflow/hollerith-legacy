// Generated by CoffeeScript 1.12.4
(function() {
  var $, $async, CND, CODEC, D, DUMP, _codec_decode, _codec_encode, _codec_encode_plus_tm_hi, _new_level_db, badge, debug, echo, help, info, leveldown, log, rpr, step, suspend, urge, warn, whisper, ƒ,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOLLERITH/main';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ƒ = CND.format_number.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  CODEC = this.CODEC = require('hollerith-codec');

  DUMP = this.DUMP = require('./dump');

  _codec_encode = CODEC.encode.bind(CODEC);

  _codec_encode_plus_tm_hi = CODEC.encode_plus_hi.bind(CODEC);

  _codec_decode = CODEC.decode.bind(CODEC);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  _new_level_db = require('level');

  leveldown = require('leveldown');

  step = (require('coffeenode-suspend')).step;

  this.phrasetypes = ['pos', 'spo'];

  this._misfit = Symbol('misfit');

  this._zero_value_bfr = new Buffer('\x00');

  this.new_db = function(path, settings) {

    /* TAINT which reference should be used for path resolution? */

    /* TAINT rename to `open_db` and make calls asynchronous? */
    var R, hollerith_sym, registry;
    path = (require('path')).resolve(process.cwd(), path);
    hollerith_sym = Symbol["for"]('HOLLERITH');
    registry = global[hollerith_sym] != null ? global[hollerith_sym] : global[hollerith_sym] = {};
    if ((R = registry[path]) != null) {
      return R;
    }
    return registry[path] = this._new_db(path, settings);
  };

  this._new_db = function(route, settings) {
    var R, create_if_missing, decoder, encoder, key, keys, level_settings, ref, ref1, ref2, substrate, unknown_keys;
    if (settings == null) {
      settings = {};
    }

    /* TAINT we should force this operation to be asynchronous; otherwise, DB may not be writeable */

    /* TAINT keep global reference to DB at route and return that if it exists? */
    if (!CND.is_subset((keys = Object.keys(settings)), this._new_db.keys)) {
      unknown_keys = ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (indexOf.call(this._new_db.keys, key) < 0) {
            results.push(key);
          }
        }
        return results;
      }).call(this)).join(', ');
      throw new Error("unknown settings keys: " + keys);
    }
    create_if_missing = (ref = settings != null ? settings['create'] : void 0) != null ? ref : true;
    encoder = (ref1 = settings != null ? settings['encoder'] : void 0) != null ? ref1 : null;
    decoder = (ref2 = settings != null ? settings['decoder'] : void 0) != null ? ref2 : null;
    level_settings = {
      'keyEncoding': 'binary',
      'valueEncoding': 'binary',
      'createIfMissing': create_if_missing,
      'errorIfExists': false,
      'compression': true,
      'sync': false
    };
    if (create_if_missing) {
      (require('mkdirp')).sync(route);
    }
    substrate = _new_level_db(route, level_settings, function(error) {
      if (error != null) {
        if (error['name'] === 'OpenError') {
          throw new Error(error['message'] + "\nUnable to open DB at " + route + ";\n* make sure folder exists\n* pass `{ create: true, }` in settings\n* make sure no other process has opened DB");
        }
        throw error;
      }
    });
    R = {
      '~isa': 'HOLLERITH/db',
      '%self': substrate,
      'encoder': encoder,
      'decoder': decoder
    };
    return R;
  };

  this._new_db.keys = ['create', 'encoder', 'decoder'];

  this.clear = function(db, handler) {
    return step((function(_this) {
      return function*(resume) {
        var route;
        route = db['%self']['location'];
        whisper("closing DB");
        yield db['%self'].close(resume);
        yield leveldown.destroy(route, resume);
        yield db['%self'].open(resume);
        whisper("erased and re-opened LevelDB at " + route);
        return handler(null);
      };
    })(this));
  };

  this._put_meta = function(db, name, value, handler) {

    /* TAINT should use own type for metadata */
    var key_bfr, value_bfr;
    key_bfr = this._encode_key(db, ['meta', name]);
    value_bfr = CND.isa_jsbuffer ? value : this._encode_value(db, value);
    return db['%self'].put(key_bfr, value_bfr, (function(_this) {
      return function(error) {
        if (handler != null) {
          return handler(error);
        }
      };
    })(this));
  };

  this._get_meta = function(db, name, fallback, handler) {
    var arity, key_bfr;
    switch (arity = arguments.length) {
      case 3:
        handler = fallback;
        fallback = this._misfit;
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expected 3 or 4 arguments, got " + arity);
    }
    key_bfr = this._encode_key(db, ['meta', name]);
    return db['%self'].get(key_bfr, (function(_this) {
      return function(error, value) {
        if (error != null) {
          if ((error['type'] === 'NotFoundError') && (fallback !== _this._misfit)) {
            return handler(null, fallback);
          }
          return handler(error);
        }
        return handler(null, value);
      };
    })(this));
  };

  this._is_meta = function(db, key_bfr) {
    return ((key_bfr.slice(0, this._meta_prefix.length)).compare(this._meta_prefix)) === 0;
  };


  /* TAINT must derive meta key prefix from result of `_put_meta` */

  this._meta_prefix = new Buffer([0x54, 0x6d, 0x65, 0x74, 0x61, 0x00]);

  this.$write = function(db, settings) {
    var $add_primary_index, $encode, $write_batch, batch_size, batch_written, ensure_unique, is_integer, loner_predicates, pipeline, ref, ref1, ref2, ref3, solid_predicates, substrate;
    if (settings == null) {
      settings = {};
    }

    /* Superficial experiments show that a much bigger batch size than 1'000 does not tend to improve
    throughput; therefore, in order to reduce memory footprint, it seems advisable to leave batch size
    in the order of around a thousand entries.
     */
    batch_size = (ref = settings['batch']) != null ? ref : 1000;
    solid_predicates = (ref1 = settings['solids']) != null ? ref1 : [];
    loner_predicates = (ref2 = settings['loners']) != null ? ref2 : [];
    ensure_unique = (ref3 = settings['unique']) != null ? ref3 : false;
    substrate = db['%self'];
    batch_written = null;
    if (ensure_unique) {
      throw new Error("`unique` setting currently not supported");
    }
    is_integer = function(x) {
      return (x != null) && (x === parseInt(x));
    };
    $add_primary_index = (function(_this) {
      return function() {
        return $(function(spo, send) {

          /* Skip signals or secondary indexes: */
          var idx, index_only, obj, prd, ref4, sbj;
          if (spo[0] === Symbol["for"]('add-secondary-index')) {
            return send(spo);
          }
          index_only = false;
          if (spo[0] === Symbol["for"]('index')) {

            /* TAINT modifying original object, should make copy */
            spo.shift();
            index_only = true;
          }
          sbj = spo[0], prd = spo[1], idx = spo[2], obj = spo[3];
          _this.validate_spo(spo);
          if (!CND.isa_list(sbj)) {
            sbj = [sbj];
          }
          if (obj == null) {
            ref4 = [idx, null], obj = ref4[0], idx = ref4[1];
          }
          if (!index_only) {
            send(['spo', sbj, prd, idx, obj]);
          }
          send(['pos', prd, idx, obj, sbj]);

          /* For each phrase that has an integer index, we store a second phrase with the index field
          set to `null` to enable queries for object values at any index. Note that as a matter of course,
          phrases with duplicate object values (which would differ solely by index) will thereby be
          conflated; in other words, this step turns lists into sets.
           */

          /* TAINT the `is_integer` function should be configurable with the `settings` object and
          be more generally named sth like `use default index` or somesuch. (???)
           */
          if (is_integer(idx)) {
            return send(['pos', prd, null, obj, sbj]);
          }
        });
      };
    })(this);
    $encode = (function(_this) {
      return function() {
        return $(function(longphrase, send) {
          return send({
            type: 'put',
            key: _this._encode_key(db, longphrase),
            value: _this._zero_value_bfr
          });
        });
      };
    })(this);
    $write_batch = (function(_this) {
      return function() {
        return $async(function(batch, send, end) {
          if (batch != null) {
            substrate.batch(batch, function() {
              return send.done(batch);
            });
          }
          if (end != null) {
            end();
          }
          return null;
        });
      };
    })(this);
    pipeline = [];
    pipeline.push($add_primary_index());
    pipeline.push(this._$add_secondary_index(db));
    pipeline.push($encode());
    pipeline.push(D.$batch(batch_size));
    pipeline.push($write_batch());
    return D.new_stream({
      pipeline: pipeline
    });
  };

  this.$index = (function(_this) {
    return function() {
      var predicates;
      predicates = 1 <= arguments.length ? slice.call(arguments, 0) : [];

      /* TAINT For the time being, we only support secondary indexes. A future version will likely support
      tertiary indexes, but that will necessitate waiting for the end of the write stream and re-reading all the
      records.
       */
      if (predicates.length !== 2) {
        throw new Error("only indexes with exactly 2 steps supported at this time");
      }
      return $('start', function(send) {
        var index_settings;
        index_settings = {
          predicates: predicates
        };
        return send([Symbol["for"]('add-secondary-index'), index_settings]);
      });
    };
  })(this);

  this._$add_secondary_index = (function(_this) {
    return function(db) {
      var index_settings_cache, lead_phrases_cache, phrase_cache, symbol_for_add_secondary_index, tail_phrases_cache;
      index_settings_cache = [];
      phrase_cache = [];
      lead_phrases_cache = {};
      tail_phrases_cache = {};
      symbol_for_add_secondary_index = Symbol["for"]('add-secondary-index');
      return $(function(phrase, send, end) {
        var _, i, index_settings, j, k, l, lead_idx, lead_obj, lead_phrase, lead_phrases, lead_phrases_by_sbj_txts, lead_prd, lead_sbj, len, len1, len2, obj, prd, predicates, sbj, sbj_txt, tail_idx, tail_obj, tail_phrase, tail_phrases, tail_phrases_by_sbj_txts, tail_prd, target;
        sbj_txt = null;
        if (phrase != null) {
          if (phrase[0] === symbol_for_add_secondary_index) {
            _ = phrase[0], index_settings = phrase[1];
            predicates = index_settings.predicates;
            lead_prd = predicates[0], tail_prd = predicates[1];
            if (lead_phrases_cache[lead_prd] == null) {
              lead_phrases_cache[lead_prd] = {};
            }
            if (tail_phrases_cache[tail_prd] == null) {
              tail_phrases_cache[tail_prd] = {};
            }
            index_settings_cache.push(index_settings);
          } else {

            /* TAINT code duplication */
            if (phrase[0] === 'pos') {
              _ = phrase[0], prd = phrase[1], _ = 5 <= phrase.length ? slice.call(phrase, 2, i = phrase.length - 2) : (i = 2, []), obj = phrase[i++], sbj = phrase[i++];
              if ((target = lead_phrases_cache[prd]) != null) {
                if (sbj_txt == null) {
                  sbj_txt = JSON.stringify(sbj);
                }
                (target[sbj_txt] != null ? target[sbj_txt] : target[sbj_txt] = []).push(phrase);
              }
              if ((target = tail_phrases_cache[prd]) != null) {
                if (sbj_txt == null) {
                  sbj_txt = JSON.stringify(sbj);
                }
                (target[sbj_txt] != null ? target[sbj_txt] : target[sbj_txt] = []).push(phrase);
              }
            }
            send(phrase);
          }
        }
        if (end != null) {
          for (j = 0, len = index_settings_cache.length; j < len; j++) {
            index_settings = index_settings_cache[j];
            predicates = index_settings.predicates;
            lead_prd = predicates[0], tail_prd = predicates[1];
            lead_phrases_by_sbj_txts = lead_phrases_cache[lead_prd];
            tail_phrases_by_sbj_txts = tail_phrases_cache[tail_prd];
            for (sbj_txt in lead_phrases_by_sbj_txts) {
              lead_phrases = lead_phrases_by_sbj_txts[sbj_txt];
              if ((tail_phrases = tail_phrases_by_sbj_txts[sbj_txt]) == null) {
                continue;
              }
              for (k = 0, len1 = lead_phrases.length; k < len1; k++) {
                lead_phrase = lead_phrases[k];
                _ = lead_phrase[0], lead_prd = lead_phrase[1], lead_idx = lead_phrase[2], lead_obj = lead_phrase[3], lead_sbj = lead_phrase[4];
                if ((CND.isa_list(lead_sbj)) && lead_sbj.length === 1) {
                  lead_sbj = lead_sbj[0];
                }
                for (l = 0, len2 = tail_phrases.length; l < len2; l++) {
                  tail_phrase = tail_phrases[l];

                  /* TAINT second clause necessary? */
                  if ((lead_phrase === tail_phrase) || (CND.equals(lead_phrase, tail_phrase))) {
                    continue;
                  }
                  _ = tail_phrase[0], tail_prd = tail_phrase[1], tail_idx = tail_phrase[2], tail_obj = tail_phrase[3], _ = tail_phrase[4];
                  send(['pos', lead_prd, lead_idx, lead_obj, [lead_sbj, tail_prd, tail_idx, tail_obj]]);

                  /* From the README: "For each phrase that has an integer ('classical') index, we store a
                  second phrase with the index field set to null to enable queries for phrase object values at
                  any index. Note that as a matter of course, phrases with duplicate object values (which would
                  differ solely by index) will thereby be conflated; in other words, this step turns lists into
                  sets."
                   */
                  if ((lead_idx !== null) || (tail_idx !== null)) {
                    send(['pos', lead_prd, null, lead_obj, [lead_sbj, tail_prd, null, tail_obj]]);
                  }
                }
              }
            }
          }
          end();
        }
        return null;
      });
    };
  })(this);

  this.validate_spo = function(spo) {

    /* Do a shallow sanity check to see whether `spo` is a triplet. */
    var ref;
    if (!CND.isa_list(spo)) {
      throw new Error("invalid SPO key, must be list: " + (rpr(spo)));
    }
    if (!((3 <= (ref = spo.length) && ref <= 4))) {
      throw new Error("invalid SPO key, must be of length 3 or 4: " + (rpr(spo)));
    }
    return null;
  };

  this.$validate_spo = function() {

    /* Do a shallow sanity check to see whether all incoming data are triplets. */
    return $((function(_this) {
      return function(spo, send) {

        /* Analyze SPO key and send all necessary POS facets: */
        var error;
        try {
          _this.validate_spo(spo);
        } catch (error1) {
          error = error1;
          return send.error(error);
        }
        return send(spo);
      };
    })(this));
  };

  this.new_phrasestream = function(db, query) {
    var arity;
    if (!((arity = arguments.length) <= 2)) {
      throw new Error("expected up to 2 arguments, got " + arity);
    }
    return this._new_phrasestream(db, query);
  };

  this.read_phrases = function(db, query, handler) {
    var arity;
    switch (arity = arguments.length) {
      case 2:
        handler = query;
        query = null;
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    return this._new_phrasestream(db, query, handler);
  };

  this.read_one_phrase = function(db, query, handler) {
    var arity, fallback;
    fallback = this._misfit;
    switch (arity = arguments.length) {
      case 2:
        handler = query;
        query = null;
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 4 or 5 arguments, got " + arity);
    }
    if ((query != null) && 'fallback' in query) {
      fallback = query['fallback'];
      delete query['fallback'];
    }
    return this.read_phrases(db, query, (function(_this) {
      return function(error, phrases) {
        if (error != null) {
          return handler(error);
        }
        if ((phrases.length === 0) && (fallback !== _this._misfit)) {
          return handler(null, fallback);
        }
        if (phrases.length !== 1) {
          return handler(new Error("expected 1 phrase, got " + phrases.length));
        }
        return handler(null, phrases[0]);
      };
    })(this));
  };

  this._new_phrasestream = function(db, query, handler) {
    var R, input;
    input = this.new_longphrasestream(db, query);
    R = input.pipe(this.$longphrase_as_phrase(db, query));
    if (handler != null) {
      R = R.pipe(D.$collect()).pipe($((function(_this) {
        return function(data, send) {
          return handler(null, data);
        };
      })(this)));
      R.on('error', (function(_this) {
        return function(error) {
          return handler(error);
        };
      })(this));
    }
    return R;
  };

  this.new_longphrasestream = function(db, query) {

    /*
    * If none of `lo`, `hi` or 'prefix' are given, the stream will iterate over all entries.
    * If both `lo` and `hi` are given, a query with lower and upper, inclusive boundaries (in LevelDB these
      are called `gte` and `lte`, respectively) is issued.
    * If only `prefix` is given, a prefix query is issued. Prefix queries may be 'exclusive' or 'inclusive'.
      Exclusive prefixes match the list elements that make up the HOLLERITH entry keys in a component-wise
      fashion, while inclusive queries also match when the last prefix element is the start of the
      corresponding component of the entry key. For example, `{ prefix: [ 'pos', 'shape', ] }` will match
      only entries whose first two key elements are `'pos'` and `'shape'`, while a query using
      `{ prefix: [ 'pos', 'shape', ], star: '*', }` will additionally match entries with such keys as
      `[ 'pos', 'shapeclass', ]` and `[ 'pos', 'shape/strokeorder', ]`.
    * If only `lo` or only `hi` is given, an error is issued.
     */
    var has_hi, has_lo, has_prefix, has_star, hi_hint, key, keys, legal_keys, lo_hint, prefix, ref, ref1, star;
    lo_hint = null;
    hi_hint = null;
    legal_keys = ['prefix', 'star', 'lo', 'hi', 'unbox', 'flatten'];
    if (query != null) {
      keys = Object.keys(query);
      has_prefix = indexOf.call(keys, 'prefix') >= 0;
      has_lo = indexOf.call(keys, 'lo') >= 0;
      has_hi = indexOf.call(keys, 'hi') >= 0;
      has_star = indexOf.call(keys, 'star') >= 0;
      star = (ref = query['star']) != null ? ref : null;
      prefix = (ref1 = query['prefix']) != null ? ref1 : null;
      if (!CND.is_subset(keys, legal_keys)) {
        legal_keys = ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = legal_keys.length; i < len; i++) {
            key = legal_keys[i];
            results.push(rpr(key));
          }
          return results;
        })()).join(', ');
        keys = ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            results.push(rpr(key));
          }
          return results;
        })()).join(', ');
        throw new Error("legal query keys are " + legal_keys + ", got " + keys);
      }
      if ((!has_prefix) && (!has_lo) && (!has_hi)) {
        has_prefix = true;
        prefix = [];
        has_star = true;
        star = '*';
      } else {
        if ((!has_prefix) && (!has_lo || !has_hi)) {
          keys = ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = keys.length; i < len; i++) {
              key = keys[i];
              results.push(rpr(key));
            }
            return results;
          })()).join(', ');
          throw new Error("must use either 'prefix' or 'hi' and 'lo', got " + keys);
        }
        if ((has_lo || has_hi) && has_star) {
          throw new Error("illegal to use 'star' with 'lo' or 'hi'");
        }
        if (has_star && (star !== '*')) {
          throw new Error("expected 'star' to be '*', got " + (rpr(star)));
        }
        if (has_prefix && (has_lo || has_hi)) {
          throw new Error("illegal to use 'hi' or 'lo' together with 'prefix'");
        }
        if ((has_lo && !has_hi) || (has_hi && !has_lo)) {
          throw new Error("illegal to use only one of 'hi' or 'lo'");
        }
      }
      if (has_prefix) {
        lo_hint = prefix;
        if (has_star) {
          hi_hint = star;
        }
      } else {
        lo_hint = query['lo'];
        hi_hint = query['hi'];
      }
    }
    return this._new_longphrasestream(db, lo_hint, hi_hint);
  };

  this._new_longphrasestream = function(db, lo_hint, hi_hint) {
    var R, hi_hint_bfr, lo_hint_bfr, query;
    if (lo_hint == null) {
      lo_hint = null;
    }
    if (hi_hint == null) {
      hi_hint = null;
    }

    /* TAINT `lo_hint` and `hi_hint` should be called `first` and `second` */
    if ((hi_hint != null) && (lo_hint == null)) {
      throw new Error("must give `lo_hint` when `hi_hint` is given");
    }
    if ((lo_hint != null) && (hi_hint == null)) {
      query = this._query_from_prefix(db, lo_hint);
    } else if ((lo_hint != null) && hi_hint === '*') {
      query = this._query_from_prefix(db, lo_hint, '*');
    } else {
      lo_hint_bfr = lo_hint != null ? this._encode_key(db, lo_hint) : null;
      hi_hint_bfr = hi_hint != null ? (this._query_from_prefix(db, hi_hint))['lte'] : null;
      query = {
        gte: lo_hint_bfr,
        lte: hi_hint_bfr
      };
    }
    R = db['%self'].createKeyStream(query);

    /* TAINT decoding transfrom should be made public */
    R = R.pipe($((function(_this) {
      return function(key, send) {
        if (!_this._is_meta(db, key)) {
          return send(_this._decode_key(db, key));
        }
      };
    })(this)));
    R['%meta'] = {};
    R['%meta']['query'] = query;
    return R;
  };

  this.has = function(db, key, handler) {
    var key_bfr;
    key_bfr = CND.isa_jsbuffer ? key : this._encode_key(db, key);
    db['%self'].get(key_bfr, (function(_this) {
      return function(error, obj_bfr) {
        if (error != null) {
          if (error['type'] === 'NotFoundError') {
            return handler(null, false);
          }
          return handler(error);
        }
        return handler(null, true);
      };
    })(this));
    return null;
  };

  this.has_any = function(db, query, handler) {
    var active, input;
    input = this.new_longphrasestream(db, query);
    active = true;
    input.pipe($((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          active = false;
          input.destroy();
          handler(null, true);
        }
        if (end != null) {
          if (active != null) {
            handler(null, false);
          }
          return end();
        }
      };
    })(this)));
    return null;
  };

  this._encode_key = function(db, key, plus_tm_hi) {
    if (key === void 0) {
      throw new Error("illegal key " + (rpr(key)));
    }
    if (plus_tm_hi) {
      return _codec_encode_plus_tm_hi(key, db['encoder']);
    }
    return _codec_encode(key, db['encoder']);
  };

  this._decode_key = function(db, key) {
    var R;
    R = _codec_decode(key, db['decoder']);
    if (R === void 0) {
      throw new Error("illegal key " + (rpr(key)));
    }
    return R;
  };

  this.longphrase_as_phrase = function(db, longphrase, settings) {
    var error, idx, obj, phrasetype, prd, ref, sbj, sbj_length, tail, tail_length;
    if (settings == null) {
      settings = {};
    }
    try {
      phrasetype = longphrase[0], tail = 2 <= longphrase.length ? slice.call(longphrase, 1) : [];
      if ((tail_length = tail.length) !== 4) {
        throw new Error("illegal phrase " + (rpr(longphrase)) + " of length " + (tail_length + 1));
      }
      switch (phrasetype) {
        case 'spo':
          sbj = tail[0], prd = tail[1], idx = tail[2], obj = tail[3];
          break;
        case 'pos':
          prd = tail[0], idx = tail[1], obj = tail[2], sbj = tail[3];
          break;
        default:
          throw new Error("unknown phrasetype " + (rpr(phrasetype)));
      }
      switch (sbj_length = sbj.length) {
        case 1:
          if ((ref = settings['unbox']) != null ? ref : true) {
            sbj = sbj[0];
          }
          break;
        case 0:
          throw new Error("subject can't be empty; read phrase " + (rpr(longphrase)));
      }
      if (phrasetype === 'spo') {
        return ['spo', sbj, prd, idx, obj];
      }
      if (settings['flatten'] && CND.isa_list(sbj)) {
        return ['pos', prd, idx, obj].concat(slice.call(sbj));
      }
      return ['pos', prd, idx, obj, sbj];
    } catch (error1) {
      error = error1;
      warn("detected problem with phrase " + (rpr(longphrase)));
      throw error;
    }
  };

  this.$longphrase_as_phrase = function(db, settings) {
    return $((function(_this) {
      return function(key, send) {
        return send(_this.longphrase_as_phrase(db, key, settings));
      };
    })(this));
  };

  this._type_from_key = function(db, key) {
    var ref;
    if (Array.isArray(key)) {
      if (ref = key['0'], indexOf.call(this.phrasetypes, ref) < 0) {
        throw new Error("illegal phrasetype: " + (rpr(key)));
      }
      return 'list';
    }
    return 'other';
  };


  /* TAINT should be public */

  this._query_from_prefix = function(db, prefix, star) {
    var base, gte, lte;
    if (star != null) {

      /* 'Asterisk' encoding: partial key segments match */
      gte = this._encode_key(db, prefix);
      lte = this._encode_key(db, prefix, true);
    } else {

      /* 'Classical' encoding: only full key segments match */
      base = this._encode_key(db, prefix, true);
      gte = base.slice(0, base.length - 1);
      lte = base.slice(0, base.length);
    }
    return {
      gte: gte,
      lte: lte
    };
  };

}).call(this);

//# sourceMappingURL=main.js.map
