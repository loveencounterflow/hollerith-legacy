// Generated by CoffeeScript 1.9.1
(function() {
  var $, BYTEWISE, CND, D, _btws_decode, _btws_encode, _new_level_db, badge, debug, echo, help, log, rpr, step, suspend, urge, warn,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'test-hollerith';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  BYTEWISE = require('bytewise');

  _btws_encode = BYTEWISE.encode.bind(BYTEWISE);

  _btws_decode = BYTEWISE.decode.bind(BYTEWISE);

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  _new_level_db = require('level');

  this._zero = _btws_encode(true);

  this._last_octet = new Buffer([0xff]);

  this.new_db = function(route) {
    var R, level_settings, substrate;
    level_settings = {
      'keyEncoding': 'binary',
      'valueEncoding': 'binary',
      'createIfMissing': true,
      'errorIfExists': false,
      'compression': true,
      'sync': false
    };
    substrate = _new_level_db(route, level_settings);
    R = {
      '~isa': 'HOLLERITH/db',
      '%self': substrate
    };
    return R;
  };

  this.clear = function(db, handler) {

    /* TAINT consider to simply remove files as it is faster and leads to more reproducible results as
    we then always really start from scratch
     */
    var count, input, substrate;
    substrate = db['%self'];
    input = substrate.createKeyStream();
    count = 0;
    return input.pipe($((function(_this) {
      return function(key, send, end) {
        return step(function*(resume) {
          if (key != null) {
            count += +1;
            (yield substrate.del(key, resume));
          }
          if (end != null) {
            help("deleted " + count + " entries");
            if (handler != null) {
              return handler(null);
            }
          }
        });
      };
    })(this)));
  };

  this._encode = function(db, key) {
    return _btws_encode(key);
  };

  this._decode = function(db, key) {
    return _btws_decode(key);
  };

  this.read = function(db, prefix) {
    if (prefix == null) {
      prefix = null;
    }
    if (prefix == null) {
      return db['%self'].createKeyStream();
    }
    return db['%self'].createKeyStream(this._query_from_prefix);
  };

  this.read_sub = function(db, settings, read) {
    var arity, indexed, insert_index, open_stream_count, ref;
    switch (arity = arguments.length) {
      case 2:
        read = settings;
        settings = null;
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    indexed = (ref = settings != null ? settings['indexed'] : void 0) != null ? ref : false;
    insert_index = indexed ? D.new_indexer() : function(x) {
      return x;
    };
    open_stream_count = 0;
    return $((function(_this) {
      return function(outer_data, outer_send, outer_end) {
        var sub_input;
        if (outer_data != null) {
          open_stream_count += +1;
          sub_input = read(outer_data).pipe((function() {
            var buffer;
            buffer = [];
            return $(function(inner_data, _, inner_end) {
              if (inner_data != null) {
                buffer.push(inner_data);
              }
              if (inner_end != null) {
                outer_send(insert_index(buffer));
                return open_stream_count += -1;
              }
            });
          })());
        }
        if (outer_end != null) {
          return repeat_immediately(function() {
            if (open_stream_count !== 0) {
              return true;
            }
            outer_end();
            return false;
          });
        }
      };
    })(this));
  };

  this.new_key = function(db, phrasetype, key_0, value_0, key_1, value_1, idx) {
    if (phrasetype !== '<' && phrasetype !== '>') {
      throw new Error("illegal phrasetype: " + (rpr(key)));
    }
    return [phrasetype, [key_0, value_0], [key_1, value_1], idx != null ? idx : null];
  };

  this.new_so_key = function() {
    var P, db;
    db = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.new_key.apply(this, [db, 'so'].concat(slice.call(P)));
  };

  this.new_os_key = function() {
    var P, db;
    db = arguments[0], P = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.new_key.apply(this, [db, 'os'].concat(slice.call(P)));
  };

  this.new_keys = function(db, phrasetype, key_0, value_0, key_1, value_1, idx) {
    var other_phrasetype;
    other_phrasetype = phrasetype === 'so' ? 'os' : 'so';
    return [this.new_key(db, phrasetype, key_0, value_0, key_1, value_1, idx), this.new_key(db, other_phrasetype, key_1, value_1, key_0, value_0, idx)];
  };

  this.new_prefix = function() {
    var db, elements, phrasetype;
    db = arguments[0], phrasetype = arguments[1], elements = 3 <= arguments.length ? slice.call(arguments, 2) : [];
    throw new Error("xxxxxxxxxx");
  };

  this._query_from_prefix = function(db, prefix) {
    var gte, last_gte_idx, lte;
    gte = Buffer.isBuffer(prefix) ? prefix : this._encode(db, prefix);

    /* `BYTEWISE` encodes lists with zeroes at the end; we skip those zeroes to arrive at a minimal prefix to
    which a `0xff` byte can be meaningfully appended:
     */
    last_gte_idx = gte.length - 1;
    while ((last_gte_idx > 0) && (gte[last_gte_idx] === 0x00)) {
      last_gte_idx += -1;
    }
    if (last_gte_idx < gte.length - 1) {
      gte = gte.slice(0, last_gte_idx + 1);
    }
    lte = Buffer.concat([gte, this._last_octet], gte.length + 1);
    return {
      gte: gte,
      lte: lte
    };
  };

}).call(this);
