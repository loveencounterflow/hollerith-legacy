// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, CODEC, D, DUMP, _codec_decode, _codec_encode, _codec_encode_plus_tm_hi, _new_level_db, badge, debug, echo, help, leveldown, log, rpr, step, suspend, urge, warn, whisper, ƒ,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOLLERITH/main';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  ƒ = CND.format_number.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  CODEC = this.CODEC = require('hollerith-codec');

  DUMP = this.DUMP = require('./dump');

  _codec_encode = CODEC.encode.bind(CODEC);

  _codec_encode_plus_tm_hi = CODEC.encode_plus_hi.bind(CODEC);

  _codec_decode = CODEC.decode.bind(CODEC);

  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  _new_level_db = require('level');

  leveldown = require('leveldown');

  step = (require('coffeenode-suspend')).step;

  this.phrasetypes = ['pos', 'spo'];

  this._misfit = Symbol('misfit');

  this._zero_value_bfr = new Buffer('\x00');

  this.new_db = function(route, settings) {

    /* TAINT we should force this operation to be asynchronous; otherwise, DB may not be writeable */
    var R, create_if_missing, decoder, encoder, level_settings, ref, ref1, ref2, ref3, size, substrate;
    create_if_missing = (ref = settings != null ? settings['create'] : void 0) != null ? ref : true;
    size = (ref1 = settings != null ? settings['size'] : void 0) != null ? ref1 : 1e5;
    encoder = (ref2 = settings != null ? settings['encoder'] : void 0) != null ? ref2 : null;
    decoder = (ref3 = settings != null ? settings['decoder'] : void 0) != null ? ref3 : null;
    level_settings = {
      'keyEncoding': 'binary',
      'valueEncoding': 'binary',
      'createIfMissing': create_if_missing,
      'errorIfExists': false,
      'compression': true,
      'sync': false
    };
    if (create_if_missing) {
      (require('mkdirp')).sync(route);
    }
    substrate = _new_level_db(route, level_settings, function(error) {
      if (error != null) {
        if (error['name'] === 'OpenError') {

          /* TAINT error also thrown with misleading message if route doesn't exist up the penultimate term */
          throw new Error("No database found at " + route + " and no `create` setting given");
        }
        throw error;
      }
    });
    R = {
      '~isa': 'HOLLERITH/db',
      '%self': substrate,
      'size': size,
      'encoder': encoder,
      'decoder': decoder
    };
    return R;
  };

  this.clear = function(db, handler) {
    return step((function(_this) {
      return function*(resume) {
        var route;
        route = db['%self']['location'];
        whisper("closing DB");
        (yield db['%self'].close(resume));
        (yield leveldown.destroy(route, resume));
        (yield db['%self'].open(resume));
        whisper("erased and re-opened LevelDB at " + route);
        return handler(null);
      };
    })(this));
  };

  this._put_meta = function(db, name, value, handler) {

    /* TAINT should use own type for metadata */
    var key_bfr, value_bfr;
    key_bfr = this._encode_key(db, ['meta', name]);
    value_bfr = CND.isa_jsbuffer ? value : this._encode_value(db, value);
    return db['%self'].put(key_bfr, value_bfr, (function(_this) {
      return function(error) {
        if (handler != null) {
          return handler(error);
        }
      };
    })(this));
  };

  this._get_meta = function(db, name, fallback, handler) {
    var arity, key_bfr;
    switch (arity = arguments.length) {
      case 3:
        handler = fallback;
        fallback = this._misfit;
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expected 3 or 4 arguments, got " + arity);
    }
    key_bfr = this._encode_key(db, ['meta', name]);
    return db['%self'].get(key_bfr, (function(_this) {
      return function(error, value) {
        if (error != null) {
          if ((error['type'] === 'NotFoundError') && (fallback !== _this._misfit)) {
            return handler(null, fallback);
          }
          return handler(error);
        }
        return handler(null, value);
      };
    })(this));
  };

  this._is_meta = function(db, key_bfr) {
    return ((key_bfr.slice(0, this._meta_prefix.length)).compare(this._meta_prefix)) === 0;
  };


  /* TAINT must derive meta key prefix from result of `_put_meta` */

  this._meta_prefix = new Buffer([0x54, 0x6d, 0x65, 0x74, 0x61, 0x00]);

  this.$write = function(db, settings) {
    var $encode, $index, $write, R, batch_size, batch_written, ensure_unique, is_integer, loner_predicates, pipeline, ref, ref1, ref2, ref3, solid_predicates, substrate;
    if (settings == null) {
      settings = {};
    }

    /* Superficial experiments show that a much bigger batch size than 1'000 does not tend to improve
    throughput; therefore, in order to reduce memory footprint, it seems advisable to leave batch size
    in the order of around a thousand entries.
     */
    batch_size = (ref = settings['batch']) != null ? ref : 1000;
    solid_predicates = (ref1 = settings['solids']) != null ? ref1 : [];
    loner_predicates = (ref2 = settings['loners']) != null ? ref2 : [];
    ensure_unique = (ref3 = settings['unique']) != null ? ref3 : true;
    substrate = db['%self'];
    R = D.create_throughstream();
    batch_written = null;
    is_integer = function(x) {
      return (x != null) && (x === parseInt(x));
    };
    $index = (function(_this) {
      return function() {
        return $(function(spo, send) {
          var idx, index_only, obj, prd, ref4, sbj;
          index_only = false;
          if (spo[0] === Symbol["for"]('index')) {
            spo.shift();
            index_only = true;
          }
          sbj = spo[0], prd = spo[1], idx = spo[2], obj = spo[3];
          _this.validate_spo(spo);
          if (!CND.isa_list(sbj)) {
            sbj = [sbj];
          }
          if (obj == null) {
            ref4 = [idx, null], obj = ref4[0], idx = ref4[1];
          }
          if (!index_only) {
            send(['spo', sbj, prd, idx, obj]);
          }
          send(['pos', prd, idx, obj, sbj]);

          /* For each phrase that has an integer index, we store a second phrase with the index field
          set to `null` to enable queries for object values at any index. Note that as a matter of course,
          phrases with duplicate object values (which would differ solely by index) will thereby be
          conflated; in other words, this step turns lists into sets.
           */

          /* TAINT the `is_integer` function should be configurable with the `settings` object and
          be more generally named sth like `use default index` or somesuch. (???)
           */
          if (is_integer(idx)) {
            return send(['pos', prd, null, obj, sbj]);
          }
        });
      };
    })(this);
    $encode = (function(_this) {
      return function() {
        return $(function(longphrase, send) {
          return send({
            type: 'put',
            key: _this._encode_key(db, longphrase),
            value: _this._zero_value_bfr
          });
        });
      };
    })(this);
    $write = (function(_this) {
      return function() {
        return $(function(batch, send) {
          substrate.batch(batch);
          batch_written();
          return send(batch);
        });
      };
    })(this);
    if (ensure_unique) {
      throw new Error("`unique` setting currently not supported");
    } else {
      batch_written = function() {};
    }
    pipeline = [];
    pipeline.push($index());
    pipeline.push($encode());
    pipeline.push(D.$batch(batch_size));
    pipeline.push($write());
    R = R.pipe(D.combine.apply(D, pipeline));
    return R;
  };

  this.validate_spo = function(spo) {

    /* Do a shallow sanity check to see whether `spo` is a triplet. */
    var ref;
    if (!CND.isa_list(spo)) {
      throw new Error("invalid SPO key, must be list: " + (rpr(spo)));
    }
    if (!((3 <= (ref = spo.length) && ref <= 4))) {
      throw new Error("invalid SPO key, must be of length 3 or 4: " + (rpr(spo)));
    }
    return null;
  };

  this.$validate_spo = function() {

    /* Do a shallow sanity check to see whether all incoming data are triplets. */
    return $((function(_this) {
      return function(spo, send) {

        /* Analyze SPO key and send all necessary POS facets: */
        var error, error1;
        try {
          _this.validate_spo(spo);
        } catch (error1) {
          error = error1;
          return send.error(error);
        }
        return send(spo);
      };
    })(this));
  };


  /* TAINT under revision
  #-----------------------------------------------------------------------------------------------------------
  @_get_bloom_methods = ( db ) ->
    #---------------------------------------------------------------------------------------------------------
    bloom_settings        = size: db[ 'size' ] ? 1e5
    seen                  = {}
    #---------------------------------------------------------------------------------------------------------
    batch_written = ->
      seen = {}
    #---------------------------------------------------------------------------------------------------------
    show_bloom_info = =>
      CND.BLOOM.report db[ '%bloom' ]
    #---------------------------------------------------------------------------------------------------------
    $ensure_unique_sp = =>
      #.......................................................................................................
      return $async ( spo, done ) =>
        [ sbj, prd, _, ]      = spo
        key                   = [ sbj, prd, ]
        key_bfr               = CODEC.encode key
        key_txt               = key_bfr.toString 'hex'
        bloom                 = db[ '%bloom' ]
        seen_has_key          = seen[ key_txt ]?
        bloom_has_key         = CND.BLOOM.has bloom, key_bfr
        #.....................................................................................................
        if seen_has_key
          warn key
          return done.error new Error "S/P pair already in DB: #{rpr key}"
        #.....................................................................................................
        seen[ key_txt ] = 1
        CND.BLOOM.add bloom, key_bfr
        #.....................................................................................................
        return done spo unless bloom_has_key
        #.....................................................................................................
        @has_any db, { prefix: [ 'spo', sbj, prd, ], }, ( error, db_has_key ) =>
          return done.error error if error?
          if db_has_key
            return done.error new Error "S/P pair already in DB: #{rpr key}"
          done spo
    #---------------------------------------------------------------------------------------------------------
    $load_bloom = =>
      is_first = yes
      return $async ( data, done ) =>
        unless is_first
          return if data? then done data else done()
        #.....................................................................................................
        is_first = no
        whisper "loading Bloom filter..."
        #.....................................................................................................
        @_get_meta db, 'bloom', null, ( error, bloom_bfr ) =>
          return done.error error if error?
          if bloom_bfr is null
            warn 'no bloom filter found'
            bloom = CND.BLOOM.new_filter bloom_settings
          else
            bloom = CND.BLOOM.from_buffer bloom_bfr
          db[ '%bloom' ] = bloom
          whisper "...ok"
          show_bloom_info()
          return if data? then done data else done()
    #---------------------------------------------------------------------------------------------------------
    $save_bloom = =>
      return $ ( data, send, end ) =>
        send data if data?
        if end?
          if db[ '%bloom' ]?
            whisper "saving Bloom filter..."
            bloom_bfr = CND.BLOOM.as_buffer db[ '%bloom' ]
            whisper "serialized bloom filter to #{ƒ bloom_bfr.length} bytes"
            show_bloom_info()
            #.................................................................................................
            @_put_meta db, 'bloom', bloom_bfr, ( error ) =>
              return send.error error if error?
              whisper "...ok"
              end()
          else
            whisper "no data written, no Bloom filter to save"
    #---------------------------------------------------------------------------------------------------------
    return { batch_written, $ensure_unique_sp, $load_bloom, $save_bloom, }
   */

  this.$index = (function(_this) {
    return function(descriptions) {
      var arities, arity, link, new_index_phrase, phrase_counts, phrases, predicate, predicate_count, predicates;
      throw new Error("deprecated");

      /* TAINT For the time being, we only support secondary indexes, and the implementation is not at all
      written in a generic fashion. A future version will likely support tertiary indexes, but that will
      necessitate waiting for the end of the write stream and re-reading all the records.
       */
      predicates = [];
      predicate_count = 0;
      arities = [];
      phrases = [];
      phrase_counts = {};
      for (predicate in descriptions) {
        arity = descriptions[predicate];
        predicate_count += +1;
        if (arity !== 'singular' && arity !== 'plural') {
          throw new Error("expected 'singular' or 'plural' for arity, got " + (rpr(arity)));
        }
        predicates.push(predicate);
        phrases.push({});
        arities.push(arity);
      }
      if (predicate_count.length < 2) {
        throw new Error("expected at least two predicate descriptions, got " + predicates.length);
      }
      if (predicate_count.length > 2) {
        throw new Error("indexes with more than 2 steps not supported yet");
      }
      new_index_phrase = function(tsbj, tprd, tobj, fprd, fobj, tsbj_is_list, idx) {
        if (idx == null) {
          idx = 0;
        }
        if (tsbj_is_list) {
          return [slice.call(tsbj).concat([tprd], [idx], [tobj]), fprd, fobj];
        }
        return [[tsbj, tprd, idx, tobj], fprd, fobj];
      };
      link = function(phrases) {
        var R, fobj, fprd, from_is_plural, from_phrase, fsbj, i, idx, j, k, l, len, len1, len2, len3, sub_fobj, sub_tobj, to_is_plural, to_phrase, tobj, tprd, tsbj, tsbj_is_list;
        if (phrases.length !== 2) {
          throw new Error("indexes with anything but 2 steps not supported yet");
        }
        from_phrase = phrases[0], to_phrase = phrases[1];
        fsbj = from_phrase[0], fprd = from_phrase[1], fobj = from_phrase[2];
        tsbj = to_phrase[0], tprd = to_phrase[1], tobj = to_phrase[2];
        tsbj_is_list = CND.isa_list(tsbj);
        from_is_plural = arities[0] === 'plural';
        to_is_plural = arities[1] === 'plural';
        if (!(from_is_plural || to_is_plural)) {
          return [new_index_phrase(tsbj, tprd, tobj, fprd, fobj, tsbj_is_list)];
        }
        idx = -1;
        R = [];
        if (from_is_plural) {
          if (to_is_plural) {
            for (i = 0, len = fobj.length; i < len; i++) {
              sub_fobj = fobj[i];
              for (j = 0, len1 = tobj.length; j < len1; j++) {
                sub_tobj = tobj[j];
                idx += +1;
                R.push(new_index_phrase(tsbj, tprd, sub_tobj, fprd, sub_fobj, tsbj_is_list, idx));
              }
            }
          } else {
            for (k = 0, len2 = fobj.length; k < len2; k++) {
              sub_fobj = fobj[k];
              idx += +1;
              R.push(new_index_phrase(tsbj, tprd, tobj, fprd, sub_fobj, tsbj_is_list, idx));
            }
          }
        } else {
          for (l = 0, len3 = tobj.length; l < len3; l++) {
            sub_tobj = tobj[l];
            idx += +1;
            R.push(new_index_phrase(tsbj, tprd, sub_tobj, fprd, fobj, tsbj_is_list, idx));
          }
        }
        return R;
      };
      return $(function(phrase, send) {
        var i, index_phrase, len, obj, phrase_target, prd, prd_idx, ref, ref1, sbj, sbj_txt;
        send(phrase);
        sbj = phrase[0], prd = phrase[1], obj = phrase[2];
        if (!((prd_idx = predicates.indexOf(prd)) >= 0)) {
          return;
        }
        sbj_txt = JSON.stringify(sbj);
        phrase_target = phrases[sbj_txt] != null ? phrases[sbj_txt] : phrases[sbj_txt] = [];
        phrase_target[prd_idx] = phrase;
        phrase_counts[sbj_txt] = ((ref = phrase_counts[sbj_txt]) != null ? ref : 0) + 1;
        if (phrase_counts[sbj_txt] < predicate_count) {
          return null;
        }
        ref1 = link(phrases[sbj_txt]);
        for (i = 0, len = ref1.length; i < len; i++) {
          index_phrase = ref1[i];
          send(index_phrase);
        }
        return null;
      });
    };
  })(this);

  this.$index_v4 = (function(_this) {
    return function() {
      var db, i, is_retro_index, len, link, new_index_phrase, phrase_counts, phrases, predicate, predicate_count, predicates;
      db = arguments[0], predicates = 2 <= arguments.length ? slice.call(arguments, 1) : [];

      /* TAINT For the time being, we only support secondary indexes, and the implementation is not at all
      written in a generic fashion. A future version will likely support tertiary indexes, but that will
      necessitate waiting for the end of the write stream and re-reading all the records.
       */
      if (predicates.length !== 2) {
        throw new Error("only indexes with exactly 2 steps supported at this time");
      }
      phrases = [];
      phrase_counts = {};
      if (is_retro_index = predicates[0] === predicates[1]) {
        predicates.pop();
        phrases.push({});
        predicate_count = 2;
      } else {
        for (i = 0, len = predicates.length; i < len; i++) {
          predicate = predicates[i];
          phrases.push({});
        }
      }
      new_index_phrase = function(fphrase, tphrase) {
        var fidx, fobj, fprd, fsubj, tidx, tobj, tprd, tsubj;
        fsubj = fphrase[0], fprd = fphrase[1], fidx = fphrase[2], fobj = fphrase[3];
        tsubj = tphrase[0], tprd = tphrase[1], tidx = tphrase[2], tobj = tphrase[3];
        return [[tsbj, tprd, tidx, tobj], fprd, fidx, fobj];
      };
      link = function(phrases) {
        var fobj, fprd, from_phrase, fsbj, j, k, len1, len2, sub_fobj, sub_tobj, to_phrase, tobj, tprd, tsbj, tsbj_is_list;
        from_phrase = phrases[0], to_phrase = phrases[1];
        fsbj = from_phrase[0], fprd = from_phrase[1], fobj = from_phrase[2];
        tsbj = to_phrase[0], tprd = to_phrase[1], tobj = to_phrase[2];
        tsbj_is_list = CND.isa_list(tsbj);
        for (j = 0, len1 = fobj.length; j < len1; j++) {
          sub_fobj = fobj[j];
          for (k = 0, len2 = tobj.length; k < len2; k++) {
            sub_tobj = tobj[k];
            idx += +1;
            R.push(new_index_phrase(tsbj, tprd, sub_tobj, fprd, sub_fobj, tsbj_is_list, idx));
          }
        }
        return R;
      };
      return $(function(phrase, send, end) {
        var idx, obj, phrase_target, prd, prd_idx, ref, sbj, sbj_txt;
        if (phrase != null) {
          send(phrase);
          sbj = phrase[0], prd = phrase[1], idx = phrase[2], obj = phrase[3];
          if (!((prd_idx = predicates.indexOf(prd)) >= 0)) {
            return;
          }
          sbj_txt = JSON.stringify(sbj);
          phrase_target = phrases[sbj_txt] != null ? phrases[sbj_txt] : phrases[sbj_txt] = [];
          phrase_target[prd_idx] = phrase;
          phrase_counts[sbj_txt] = ((ref = phrase_counts[sbj_txt]) != null ? ref : 0) + 1;
          if (phrase_counts[sbj_txt] < predicate_count) {
            return null;
          }
        }
        debug('5543', phrases[sbj_txt]);
        if (end != null) {
          end();
        }
        return null;
      });
    };
  })(this);

  this.create_phrasestream = function(db, query, settings) {
    var R;
    R = this._create_phrasestream(db, query, settings);
    return R;
  };

  this.read_phrases = function(db, query, handler) {
    var arity;
    switch (arity = arguments.length) {
      case 2:
        handler = query;
        query = null;
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    return this._create_phrasestream(db, query, handler);
  };

  this.read_one_phrase = function(db, query, handler) {
    var arity, fallback;
    fallback = this._misfit;
    switch (arity = arguments.length) {
      case 2:
        handler = query;
        query = null;
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 4 or 5 arguments, got " + arity);
    }
    if ((query != null) && 'fallback' in query) {
      fallback = query['fallback'];
      delete query['fallback'];
    }
    return this.read_phrases(db, query, (function(_this) {
      return function(error, phrases) {
        if (error != null) {
          return handler(error);
        }
        if ((phrases.length === 0) && (fallback !== _this._misfit)) {
          return handler(null, fallback);
        }
        if (phrases.length !== 1) {
          return handler(new Error("expected 1 phrase, got " + phrases.length));
        }
        return handler(null, phrases[0]);
      };
    })(this));
  };

  this._create_phrasestream = function(db, query, handler) {
    var R, input;
    input = this.create_longphrasestream(db, query);
    R = input.pipe(this.$longphrase_as_phrase(db, query));
    if (handler != null) {
      R = R.pipe(D.$collect()).pipe($((function(_this) {
        return function(data, send) {
          return handler(null, data);
        };
      })(this)));
      R.on('error', (function(_this) {
        return function(error) {
          return handler(error);
        };
      })(this));
    }
    return R;
  };

  this.create_longphrasestream = function(db, query) {

    /*
    * If none of `lo`, `hi` or 'prefix' are given, the stream will iterate over all entries.
    * If both `lo` and `hi` are given, a query with lower and upper, inclusive boundaries (in LevelDB these
      are called `gte` and `lte`, respectively) is issued.
    * If only `prefix` is given, a prefix query is issued. Prefix queries may be 'exclusive' or 'inclusive'.
      Exclusive prefixes match the list elements that make up the HOLLERITH entry keys in a component-wise
      fashion, while inclusive queries also match when the last prefix element is the start of the
      corresponding component of the entry key. For example, `{ prefix: [ 'pos', 'shape', ] }` will match
      only entries whose first two key elements are `'pos'` and `'shape'`, while a query using
      `{ prefix: [ 'pos', 'shape', ], star: '*', }` will additionally match entries with such keys as
      `[ 'pos', 'shapeclass', ]` and `[ 'pos', 'shape/strokeorder', ]`.
    * If only `lo` or only `hi` is given, an error is issued.
     */
    var has_hi, has_lo, has_prefix, has_star, hi_hint, key, keys, legal_keys, lo_hint, prefix, ref, ref1, star;
    lo_hint = null;
    hi_hint = null;
    legal_keys = ['prefix', 'star', 'lo', 'hi', 'unbox', 'flatten'];
    if (query != null) {
      keys = Object.keys(query);
      has_prefix = indexOf.call(keys, 'prefix') >= 0;
      has_lo = indexOf.call(keys, 'lo') >= 0;
      has_hi = indexOf.call(keys, 'hi') >= 0;
      has_star = indexOf.call(keys, 'star') >= 0;
      star = (ref = query['star']) != null ? ref : null;
      prefix = (ref1 = query['prefix']) != null ? ref1 : null;
      if (!CND.is_subset(keys, legal_keys)) {
        legal_keys = ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = legal_keys.length; i < len; i++) {
            key = legal_keys[i];
            results.push(rpr(key));
          }
          return results;
        })()).join(', ');
        keys = ((function() {
          var i, len, results;
          results = [];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            results.push(rpr(key));
          }
          return results;
        })()).join(', ');
        throw new Error("legal query keys are " + legal_keys + ", got " + keys);
      }
      if ((!has_prefix) && (!has_lo) && (!has_hi)) {
        has_prefix = true;
        prefix = [];
        has_star = true;
        star = '*';
      } else {
        if ((!has_prefix) && (!has_lo || !has_hi)) {
          keys = ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = keys.length; i < len; i++) {
              key = keys[i];
              results.push(rpr(key));
            }
            return results;
          })()).join(', ');
          throw new Error("must use either 'prefix' or 'hi' and 'lo', got " + keys);
        }
        if ((has_lo || has_hi) && has_star) {
          throw new Error("illegal to use 'star' with 'lo' or 'hi'");
        }
        if (has_star && (star !== '*')) {
          throw new Error("expected 'star' to be '*', got " + (rpr(star)));
        }
        if (has_prefix && (has_lo || has_hi)) {
          throw new Error("illegal to use 'hi' or 'lo' together with 'prefix'");
        }
        if ((has_lo && !has_hi) || (has_hi && !has_lo)) {
          throw new Error("illegal to use only one of 'hi' or 'lo'");
        }
      }
      if (has_prefix) {
        lo_hint = prefix;
        if (has_star) {
          hi_hint = star;
        }
      } else {
        lo_hint = query['lo'];
        hi_hint = query['hi'];
      }
    }
    return this._create_longphrasestream(db, lo_hint, hi_hint);
  };

  this._create_longphrasestream = function(db, lo_hint, hi_hint) {
    var R, hi_hint_bfr, lo_hint_bfr, query;
    if (lo_hint == null) {
      lo_hint = null;
    }
    if (hi_hint == null) {
      hi_hint = null;
    }

    /* TAINT `lo_hint` and `hi_hint` should be called `first` and `second` */
    if ((hi_hint != null) && (lo_hint == null)) {
      throw new Error("must give `lo_hint` when `hi_hint` is given");
    }
    if ((lo_hint != null) && (hi_hint == null)) {
      query = this._query_from_prefix(db, lo_hint);
    } else if ((lo_hint != null) && hi_hint === '*') {
      query = this._query_from_prefix(db, lo_hint, '*');
    } else {
      lo_hint_bfr = lo_hint != null ? this._encode_key(db, lo_hint) : null;
      hi_hint_bfr = hi_hint != null ? (this._query_from_prefix(db, hi_hint))['lte'] : null;
      query = {
        gte: lo_hint_bfr,
        lte: hi_hint_bfr
      };
    }
    R = db['%self'].createKeyStream(query);

    /* TAINT decoding transfrom should be made public */
    R = R.pipe($((function(_this) {
      return function(key, send) {
        if (!_this._is_meta(db, key)) {
          return send(_this._decode_key(db, key));
        }
      };
    })(this)));
    R['%meta'] = {};
    R['%meta']['query'] = query;
    return R;
  };

  this.has = function(db, key, handler) {
    var key_bfr;
    key_bfr = CND.isa_jsbuffer ? key : this._encode_key(db, key);
    db['%self'].get(key_bfr, (function(_this) {
      return function(error, obj_bfr) {
        if (error != null) {
          if (error['type'] === 'NotFoundError') {
            return handler(null, false);
          }
          return handler(error);
        }
        return handler(null, true);
      };
    })(this));
    return null;
  };

  this.has_any = function(db, query, handler) {
    var active, input;
    input = this.create_longphrasestream(db, query);
    active = true;
    input.pipe($((function(_this) {
      return function(data, send, end) {
        if (data != null) {
          active = false;
          input.destroy();
          handler(null, true);
        }
        if (end != null) {
          if (active != null) {
            handler(null, false);
          }
          return end();
        }
      };
    })(this)));
    return null;
  };

  this._encode_key = function(db, key, plus_tm_hi) {
    if (key === void 0) {
      throw new Error("illegal key " + (rpr(key)));
    }
    if (plus_tm_hi) {
      return _codec_encode_plus_tm_hi(key, db['encoder']);
    }
    return _codec_encode(key, db['encoder']);
  };

  this._decode_key = function(db, key) {
    var R;
    R = _codec_decode(key, db['decoder']);
    if (R === void 0) {
      throw new Error("illegal key " + (rpr(key)));
    }
    return R;
  };

  this.longphrase_as_phrase = function(db, longphrase, settings) {
    var error, error1, idx, obj, phrasetype, prd, ref, sbj, sbj_length, tail, tail_length;
    if (settings == null) {
      settings = {};
    }
    try {
      phrasetype = longphrase[0], tail = 2 <= longphrase.length ? slice.call(longphrase, 1) : [];
      if ((tail_length = tail.length) !== 4) {
        throw new Error("illegal phrase " + (rpr(phrase)) + " of length " + (tail_length + 1));
      }
      switch (phrasetype) {
        case 'spo':
          sbj = tail[0], prd = tail[1], idx = tail[2], obj = tail[3];
          break;
        case 'pos':
          prd = tail[0], idx = tail[1], obj = tail[2], sbj = tail[3];
          break;
        default:
          throw new Error("unknown phrasetype " + (rpr(phrasetype)));
      }
      switch (sbj_length = sbj.length) {
        case 1:
          if ((ref = settings['unbox']) != null ? ref : true) {
            sbj = sbj[0];
          }
          break;
        case 0:
          throw new Error("subject can't be empty; read phrase " + (rpr(longphrase)));
      }
      if (phrasetype === 'spo') {
        return ['spo', sbj, prd, idx, obj];
      }
      if (settings['flatten'] && CND.isa_list(sbj)) {
        return ['pos', prd, idx, obj].concat(slice.call(sbj));
      }
      return ['pos', prd, idx, obj, sbj];
    } catch (error1) {
      error = error1;
      warn("detected problem with phrase " + (rpr(longphrase)));
      throw error;
    }
  };

  this.$longphrase_as_phrase = function(db, settings) {
    return $((function(_this) {
      return function(key, send) {
        return send(_this.longphrase_as_phrase(db, key, settings));
      };
    })(this));
  };

  this._type_from_key = function(db, key) {
    var ref;
    if (Array.isArray(key)) {
      if (ref = key['0'], indexOf.call(this.phrasetypes, ref) < 0) {
        throw new Error("illegal phrasetype: " + (rpr(key)));
      }
      return 'list';
    }
    return 'other';
  };


  /* TAINT should be public */

  this._query_from_prefix = function(db, prefix, star) {
    var base, gte, lte;
    if (star != null) {

      /* 'Asterisk' encoding: partial key segments match */
      gte = this._encode_key(db, prefix);
      lte = this._encode_key(db, prefix, true);
    } else {

      /* 'Classical' encoding: only full key segments match */
      base = this._encode_key(db, prefix, true);
      gte = base.slice(0, base.length - 1);
      lte = base.slice(0, base.length);
    }
    return {
      gte: gte,
      lte: lte
    };
  };

}).call(this);

//# sourceMappingURL=main.js.map
