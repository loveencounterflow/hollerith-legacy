// Generated by CoffeeScript 1.12.4
(function() {
  var $, $async, ASYNC, CHR, CND, D, HOLLERITH, KWIC, alert, badge, debug, echo, help, info, join, log, new_db, njs_path, options, rpr, step, urge, warn, whisper, ƒ,
    slice = [].slice;

  njs_path = require('path');

  join = njs_path.join;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOLLERITH/demo';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  step = (require('coffeenode-suspend')).step;

  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  ASYNC = require('async');

  CHR = require('coffeenode-chr');

  KWIC = require('kwic');

  new_db = require('level');

  HOLLERITH = require('./main');

  ƒ = CND.format_number.bind(CND);

  options = null;

  this._misfit = Symbol('misfit');

  D.new_indexer = function(idx) {
    if (idx == null) {
      idx = 0;
    }
    return (function(_this) {
      return function(data) {
        return [idx++, data];
      };
    })(this);
  };

  this.initialize = function(handler) {
    options['db'] = HOLLERITH.new_db(options['route']);
    return handler(null);
  };

  this.main = function(first_query) {
    if (first_query == null) {
      first_query = {
        gte: 'os|rank/cjt:0',
        lte: 'os|rank/cjt:9'
      };
    }
    return step((function(_this) {
      return function*(resume) {
        var count_chrs, db, input;
        yield _this.initialize(resume);
        db = options['db'];
        count_chrs = function(text) {
          return (CHR.chrs_from_text(text, {
            input: 'xncr'
          })).length;
        };
        input = db['%self'].createKeyStream(first_query);

        /* TAINT We can currently not use `HOLLERITH2.read_sub` because HOLLERITH2 assumes a key-only
        DB that uses binary encoding with a custom https://github.com/deanlandolt/bytewise layer; the current
        Jizura DB version uses UTF-8 strings and is a key/value DB.
         */
        return input.pipe(_this._$split_bkey()).pipe(_this.read_sub(db, {
          indexed: true
        }, function(key) {
          var glyph, ok, pt, rank, sk, sub_key;
          pt = key[0], ok = key[1], rank = key[2], sk = key[3], glyph = key[4];
          sub_key = "so|glyph:" + glyph + "|pod:";
          return db['%self'].createValueStream({
            gte: sub_key,
            lte: sub_key + '\uffff'
          });
        })).pipe(D.$densort(0, 0, true)).pipe($(function(arg, send) {
          var glyph, idx, lineup, pod, ref, strokeorder;
          idx = arg[0], (ref = arg[1], pod = ref[0]);
          debug('©jd5cE', pod);
          if (pod['strokeorder/short'] == null) {
            return warn('©9YXoq', pod);
          } else {
            glyph = pod['glyph/uchr'];
            strokeorder = pod['strokeorder/short'][0].length;
            lineup = pod['guide/lineup/uchr'].replace(/\u3000/g, '');
            return send([glyph, strokeorder, lineup]);
          }
        })).pipe($(function(arg, send) {
          var glyph, lineup, strokeorder;
          glyph = arg[0], strokeorder = arg[1], lineup = arg[2];
          return send([glyph, strokeorder, count_chrs(lineup)]);
        })).pipe(D.$sort(function(a, b) {
          var idx;
          idx = 1;
          if (a[idx] > b[idx]) {
            return +1;
          }
          if (a[idx] < b[idx]) {
            return -1;
          }
          return 0;
        })).pipe(D.$show());
      };
    })(this));
  };

  this._$split_bkey = function() {
    return $((function(_this) {
      return function(bkey, send) {
        return send(_this._split_bkey(bkey));
      };
    })(this));
  };

  this._split_bkey = function(bkey) {
    var R;
    R = bkey.toString('utf-8');
    R = (R.split('|')).slice(0, 3);
    R = [R[0]].concat(slice.call(R[1].split(':')), slice.call(R[2].split(':')));
    return R;
  };

  this._$split_so_bkey = function() {
    return $((function(_this) {
      return function(bkey, send) {
        return send(_this._split_so_bkey(bkey));
      };
    })(this));
  };

  this._split_so_bkey = function(bkey) {
    var R, idx_txt;
    R = bkey.toString('utf-8');
    R = R.split('|');
    idx_txt = R[3];
    R = [(R[1].split(':'))[1]].concat(slice.call(R[2].split(':')));
    if ((idx_txt != null) && idx_txt.length > 0) {
      R.push(parseInt(idx_txt, 10));
    }
    return R;
  };

  this._lte_from_gte = function(gte) {
    var R, last_idx;
    R = new Buffer((last_idx = Buffer.byteLength(gte)) + 1);
    R.write(gte);
    R[last_idx] = 0xff;
    return R;
  };

  this.$lineup_from_glyph = function(db) {
    var settings;
    settings = {
      indexed: false,
      single: true
    };
    return this.read_sub(db, settings, (function(_this) {
      return function(glyph) {
        var lte, sub_input;
        lte = "so|glyph:" + glyph + "|guide/lineup/uchr:";
        sub_input = db['%self'].createKeyStream({
          gte: lte,
          lte: _this._lte_from_gte(lte)
        });
        return sub_input;
      };
    })(this));
  };

  this.$shapeclass_wbf_from_glyph_and_lineup = function(db) {

    /* TAINT wrong */
    var settings;
    settings = {
      indexed: false,
      single: true
    };
    return this.read_sub(db, settings, (function(_this) {
      return function(arg) {
        var glyph, i, len, lineup_glyph, lineup_glyphs, results;
        glyph = arg[0], lineup_glyphs = arg[1];
        results = [];
        for (i = 0, len = lineup_glyphs.length; i < len; i++) {
          lineup_glyph = lineup_glyphs[i];
          results.push((function(lineup_glyph) {
            var gte, sub_input;
            gte = "so|glyph:" + lineup_glyph + "|factor/strokeclass/wbf:";
            sub_input = db['%self'].createKeyStream({
              gte: gte,
              lte: _this._lte_from_gte(gte)
            });
            return sub_input;
          })(lineup_glyph));
        }
        return results;
      };
    })(this));
  };

  HOLLERITH.$pick_subject = function() {
    return $((function(_this) {
      return function(lkey, send) {
        var _, pt, v0, v1;
        pt = lkey[0], _ = lkey[1], v0 = lkey[2], _ = lkey[3], v1 = lkey[4];
        return send(pt === 'so' ? v0 : v1);
      };
    })(this));
  };

  HOLLERITH.$pick_object = function() {
    return $((function(_this) {
      return function(lkey, send) {
        var _, pt, v0, v1;
        pt = lkey[0], _ = lkey[1], v0 = lkey[2], _ = lkey[3], v1 = lkey[4];
        return send(pt === 'so' ? v1 : v0);
      };
    })(this));
  };

  HOLLERITH.$pick_values = function() {
    return $((function(_this) {
      return function(lkey, send) {
        var _, pt, v0, v1;
        pt = lkey[0], _ = lkey[1], v0 = lkey[2], _ = lkey[3], v1 = lkey[4];
        return send(pt === 'so' ? [v0, v1] : [v1, v0]);
      };
    })(this));
  };

  this.dump_jizura_db = function() {
    var input, prefix, source_db;
    source_db = HOLLERITH.new_db('/Volumes/Storage/temp/jizura-hollerith2');
    prefix = ['spo', '𡏠'];
    prefix = ['spo', '㔰'];
    input = HOLLERITH.create_phrasestream(source_db, prefix);
    return input.pipe(D.$count(function(count) {
      return help("read " + count + " keys");
    })).pipe($((function(_this) {
      return function(data, send) {
        return send(JSON.stringify(data));
      };
    })(this))).pipe(D.$show());
  };

  this.find_good_kwic_sample_glyphs_3 = function(db) {

    /* version for Hollerith2 DBs; using `HOLLERITH.remit_async` instead of `HOLLERITH.read_sub`. */

    /*
    *  ▶  '[["勷",5,9907,["亠","吅","𠀎","𧘇","力"]],"41","25","11","35","53"]'
    *  ▶  '[["噿",5,13090,["口","羽","亠","从","十"]],"25","54","41","34","12"]'
    *  ▶  '[["塾",5,3818,["亠","口","子","丸","土"]],"41","25","51","35","12"]'
    *  ▶  '[["墩",5,5457,["土","亠","口","子","夊"]],"12","41","25","51","35"]'
    *  ▶  '[["孃",5,7225,["女","亠","吅","𠀎","𧘇"]],"53","41","25","11","35"]'
    *  ▶  '[["寡",5,3412,["宀","丆","且","八","刀"]],"44","13","25","34","53"]'
    *  ▶  '[["巕",5,13586,["山","卄","𠂤","辛","女"]],"25","12","32","41","53"]'
    *  ▶  '[["橔",5,13883,["木","亠","口","子","夊"]],"12","41","25","51","35"]'
    *  ▶  '[["灂",5,12349,["氵","爫","罒","","寸"]],"44","34","25","51","12"]'
    *  ▶  '[["纏",5,3421,["糹","广","里","八","土"]],"55","41","25","34","12"]'
    *  ▶  '[["纕",5,8882,["糹","亠","吅","𠀎","𧘇"]],"55","41","25","11","35"]'
    *  ▶  '[["鄸",5,8392,["卄","罒","冖","夕","阝"]],"12","25","45","35","52"]'
    *  ▶  '[["韽",5,10377,["亽","𠃌","酉","立","日"]],"34","5","12","41","25"]'
    *  ▶  '[["頀",5,8385,["立","日","卄","隹","又"]],"41","25","12","32","54"]'
    *  ▶  '[["驐",5,12644,["馬","亠","口","子","夊"]],"12","41","25","51","35"]'
    *  ▶  '[["骧",5,6010,["马","亠","吅","𠀎","𧘇"]],"55","41","25","11","35"]'
     */
    return step((function(_this) {
      return function(resume) {
        var chrs_from_text, db_route, decode_lineup, input, prefix, query, xncr_from_uchr;
        db_route = join(__dirname, '../../jizura-datasources/data/leveldb-v2');
        if (db == null) {
          db = HOLLERITH.new_db(db_route, {
            create: false
          });
        }
        help("using DB at " + db['%self']['location']);
        CHR = require(join(__dirname, '../../coffeenode-chr'));
        chrs_from_text = function(text) {
          return CHR.chrs_from_text(text, {
            input: 'xncr'
          });
        };
        prefix = ['pos', 'guide/lineup/length', 5];
        query = {
          prefix: prefix
        };
        input = HOLLERITH.create_phrasestream(db, query);
        decode_lineup = function(lineup) {
          return chrs_from_text(lineup.replace(/\u3000/g, ''));
        };
        xncr_from_uchr = function(uchr) {
          if ((CHR.as_rsg(uchr)) === 'u-pua') {
            return CHR.as_xncr(uchr, {
              csg: 'jzr'
            });
          } else {
            return uchr;
          }
        };
        return input.pipe($async(function(phrase, done) {
          var _, glyph, lineup_length, sub_fallback, sub_prefix, sub_query;
          _ = phrase[0], _ = phrase[1], lineup_length = phrase[2], glyph = phrase[3];
          sub_prefix = ['spo', glyph, 'rank/cjt'];
          sub_fallback = [null, null, null, 2e308];
          sub_query = {
            prefix: sub_prefix,
            fallback: sub_fallback
          };
          if (glyph === '公') {
            debug('©zfQhm', phrase, sub_prefix);
          }
          return HOLLERITH.read_one_phrase(db, sub_query, function(error, sub_phrase) {
            var rank;
            if (error != null) {
              return done.error(error);
            }
            _ = sub_phrase[0], _ = sub_phrase[1], _ = sub_phrase[2], rank = sub_phrase[3];
            return done([
              glyph, {
                lineup_length: lineup_length,
                rank: rank
              }
            ]);
          });
        })).pipe(D.$filter(function(arg) {
          var glyph, lineup_length, rank, ref;
          glyph = arg[0], (ref = arg[1], lineup_length = ref.lineup_length, rank = ref.rank);
          return rank < 15000;
        })).pipe($async(function(entry, done) {
          var glyph, lineup_length, rank, ref, sub_prefix, sub_query;
          glyph = entry[0], (ref = entry[1], lineup_length = ref.lineup_length, rank = ref.rank);
          sub_prefix = ['spo', glyph, 'guide/lineup/uchr'];
          sub_query = {
            prefix: sub_prefix,
            star: '*',
            fallback: null
          };
          return HOLLERITH.read_one_phrase(db, sub_query, function(error, sub_phrase) {
            var _, guides;
            if (error != null) {
              return done.error(error);
            }
            if (sub_phrase == null) {
              return done();
            }
            _ = sub_phrase[0], _ = sub_phrase[1], _ = sub_phrase[2], guides = sub_phrase[3];
            guides = decode_lineup(guides);
            return done([
              glyph, {
                lineup_length: lineup_length,
                rank: rank,
                guides: guides
              }
            ]);
          });
        })).pipe($async(function(entry, done) {
          var fn, glyph, guide, guides, i, len, lineup_length, rank, ref, tasks;
          glyph = entry[0], (ref = entry[1], lineup_length = ref.lineup_length, rank = ref.rank, guides = ref.guides);
          tasks = [];
          fn = function(guide) {
            var guide_xncr, sub_fallback, sub_prefix, sub_query;
            guide_xncr = xncr_from_uchr(guide);
            sub_prefix = ['spo', guide_xncr, 'factor/shapeclass/wbf'];
            sub_fallback = [null, null, null, 'X'];
            sub_query = {
              prefix: sub_prefix,
              fallback: sub_fallback
            };
            return tasks.push(function(handler) {
              return HOLLERITH.read_one_phrase(db, sub_query, handler);
            });
          };
          for (i = 0, len = guides.length; i < len; i++) {
            guide = guides[i];
            fn(guide);
          }
          return ASYNC.parallelLimit(tasks, 10, function(error, sub_phrases) {
            var _, j, len1, strokeclasses, strokeorder, sub_idx, sub_phrase;
            if (error != null) {
              return done.error(error);
            }
            strokeclasses = [];
            for (sub_idx = j = 0, len1 = sub_phrases.length; j < len1; sub_idx = ++j) {
              sub_phrase = sub_phrases[sub_idx];
              _ = sub_phrase[0], _ = sub_phrase[1], _ = sub_phrase[2], strokeorder = sub_phrase[3];
              strokeclasses[sub_idx] = strokeorder[0];
            }
            return done([
              glyph, {
                lineup_length: lineup_length,
                rank: rank,
                guides: guides,
                strokeclasses: strokeclasses
              }
            ]);
          });
        })).pipe(D.$filter(function(entry) {
          var glyph, guides, lineup_length, rank, ref, strokeclasses;
          glyph = entry[0], (ref = entry[1], lineup_length = ref.lineup_length, rank = ref.rank, guides = ref.guides, strokeclasses = ref.strokeclasses);
          return (strokeclasses.slice(0).sort().join('')) === '12345';
        })).pipe($(function(arg, send) {
          var glyph, guides, lineup_length, rank, ref, strokeclasses;
          glyph = arg[0], (ref = arg[1], lineup_length = ref.lineup_length, rank = ref.rank, guides = ref.guides, strokeclasses = ref.strokeclasses);
          guides = guides.join('');
          strokeclasses = strokeclasses.join('');
          return send([
            glyph, {
              lineup_length: lineup_length,
              rank: rank,
              guides: guides,
              strokeclasses: strokeclasses
            }
          ]);
        })).pipe(D.$show());
      };
    })(this));
  };

  this.read_factors = function(db, handler) {
    return step((function(_this) {
      return function(resume) {
        var Z, db_route, input, prefix, query;
        Z = {};
        db_route = join(__dirname, '../../jizura-datasources/data/leveldb-v2');
        if (db == null) {
          db = HOLLERITH.new_db(db_route, {
            create: false
          });
        }
        prefix = ['pos', 'factor/'];
        query = {
          prefix: prefix,
          star: '*'
        };
        input = HOLLERITH.create_phrasestream(db, query);
        return input.pipe((function() {
          var last_sbj, target;
          last_sbj = null;
          target = null;
          return $(function(phrase, send, end) {
            var _, obj, prd, sbj;
            if (phrase != null) {
              _ = phrase[0], prd = phrase[1], obj = phrase[2], sbj = phrase[3];
              prd = prd.replace(/^factor\//g, '');
              sbj = CHR.as_uchr(sbj, {
                input: 'xncr'
              });
              if (sbj !== last_sbj) {
                if (target != null) {
                  send(target);
                }
                target = Z[sbj] != null ? Z[sbj] : Z[sbj] = {
                  glyph: sbj
                };
                last_sbj = sbj;
              }
              target[prd] = obj;
              if (prd === 'sortcode') {
                Z[obj] = target;
              }
            }
            if (end != null) {
              if (target != null) {
                send(target);
              }
              return end();
            }
          });
        })()).pipe(D.$on_end(function() {
          return handler(null, Z);
        }));
      };
    })(this));
  };

  this.read_sample = function(db, limit_or_list, handler) {

    /* Return a gamut of select glyphs from the DB. `limit_or_list` may be a list of glyphs or a number
    representing an upper bound to the usage rank recorded as `rank/cjt`. If `limit_or_list` is a list,
    a POD whose keys are the glyphs in the list is returned; if it is a number, a similar POD with all the
    glyphs whose rank is not worse than the given limit is returned. If `limit_or_list` is smaller than zero
    or equals infinity, `null` is returned to indicate absence of a filter.
     */
    var Z, db_route, glyph, hi, i, input, len, lo, query;
    Z = {};
    if (CND.isa_list(limit_or_list)) {
      for (i = 0, len = limit_or_list.length; i < len; i++) {
        glyph = limit_or_list[i];
        Z[glyph] = 1;
      }
      return handler(null, Z);
    }
    if (limit_or_list < 0 || limit_or_list === 2e308) {
      return handler(null, null);
    }
    if (!CND.isa_number(limit_or_list)) {
      throw new Error("expected list or number, got a " + type);
    }
    db_route = join(__dirname, '../../jizura-datasources/data/leveldb-v2');
    if (db == null) {
      db = HOLLERITH.new_db(db_route, {
        create: false
      });
    }
    lo = ['pos', 'rank/cjt', 0];
    hi = ['pos', 'rank/cjt', limit_or_list];
    query = {
      lo: lo,
      hi: hi
    };
    input = HOLLERITH.create_phrasestream(db, query);
    return input.pipe($((function(_this) {
      return function(phrase, send) {
        var _;
        _ = phrase[0], _ = phrase[1], _ = phrase[2], glyph = phrase[3];
        return Z[glyph] = 1;
      };
    })(this))).pipe(D.$on_end(function() {
      return handler(null, Z);
    }));
  };

  this.show_kwic_v2_and_v3_sample = function(db) {
    return step((function(_this) {
      return function*(resume) {
        var $exclude_gaiji, $extract_lineup, $format_sortcode_v3, $include_sample, $reorder_phrase, $transform_v1_v2, $transform_v3, $unpack, db_route, factor_infos, include, input_v1, input_v2, input_v3, query_v1, query_v2, query_v3, ranks, sample;
        db_route = join(__dirname, '../../jizura-datasources/data/leveldb-v2');
        if (db == null) {
          db = HOLLERITH.new_db(db_route, {
            create: false
          });
        }
        help("using DB at " + db['%self']['location']);
        factor_infos = (yield _this.read_factors(db, resume));
        help("read " + (Object.keys(factor_infos)).length + " entries for factor_infos");
        ranks = {};
        include = 2e308;
        include = 15000;
        include = 50;
        include = 5000;
        sample = (yield _this.read_sample(db, include, resume));
        $reorder_phrase = function() {
          return $(function(phrase, send) {

            /* extract sortcode */
            var _, glyph, sortcode;
            _ = phrase[0], _ = phrase[1], sortcode = phrase[2], glyph = phrase[3], _ = phrase[4];
            return send([glyph, sortcode]);
          });
        };
        $exclude_gaiji = function() {
          return D.$filter(function(arg) {
            var glyph, sortcode;
            glyph = arg[0], sortcode = arg[1];
            return (!glyph.startsWith('&')) || (glyph.startsWith('&jzr#'));
          });
        };
        $include_sample = function() {
          return D.$filter(function(arg) {
            var glyph, sortcode;
            glyph = arg[0], sortcode = arg[1];
            if (sample != null) {
              return glyph in sample;
            } else {
              return true;
            }
          });
        };
        $extract_lineup = function() {
          return $(function(arg, send) {
            var _, glyph, infix, lineup, prefix, ref, ref1, sortcode, suffix;
            glyph = arg[0], sortcode = arg[1];
            ref = sortcode.split(';'), _ = ref[0], lineup = ref[1];
            ref1 = lineup.split(','), infix = ref1[0], suffix = ref1[1], prefix = ref1[2];
            lineup = prefix + '|' + infix + suffix;
            return send([glyph, lineup]);
          });
        };
        $format_sortcode_v3 = function() {
          return $(function(arg, send) {
            var glyph, infix, lineup, prefix, sortcode, sortcode_plus, suffix;
            glyph = arg[0], sortcode_plus = arg[1];
            sortcode = sortcode_plus[0], infix = sortcode_plus[1], suffix = sortcode_plus[2], prefix = sortcode_plus[3];
            while (!(prefix.length >= 6)) {
              prefix.unshift('\u3000');
            }
            while (!(suffix.length >= 6)) {
              suffix.push('\u3000');
            }
            prefix = prefix.join('');
            suffix = suffix.join('');
            lineup = prefix + '|' + infix + suffix;
            return send([glyph, lineup, sortcode]);
          });
        };
        $unpack = function() {
          return $(function(arg, send) {
            var ref, v1, v2, v3;
            (ref = arg[0], v1 = ref[0], v2 = ref[1]), v3 = arg[1];
            return send([v1, v2, v3]);
          });
        };
        $transform_v1_v2 = function() {
          return D.combine([$reorder_phrase(), $exclude_gaiji(), $include_sample(), $extract_lineup()]);
        };
        $transform_v3 = function() {
          return D.combine([$reorder_phrase(), $exclude_gaiji(), $include_sample(), $format_sortcode_v3()]);
        };
        query_v1 = {
          prefix: ['pos', 'guide/kwic/v1/sortcode']
        };
        query_v2 = {
          prefix: ['pos', 'guide/kwic/v2/sortcode']
        };
        query_v3 = {
          prefix: ['pos', 'guide/kwic/v3/sortcode']
        };
        input_v1 = (HOLLERITH.create_phrasestream(db, query_v1)).pipe($transform_v1_v2());
        input_v2 = (HOLLERITH.create_phrasestream(db, query_v2)).pipe($transform_v1_v2());
        input_v3 = (HOLLERITH.create_phrasestream(db, query_v3)).pipe($transform_v3());
        input_v1.pipe(D.$lockstep(input_v2, {
          fallback: [null, null]
        })).pipe(D.$lockstep(input_v3)).pipe($unpack()).pipe((function() {
          var last_guide;
          last_guide = null;
          return $(function(arg, send) {
            var glyph_v1, lineup_v1, linup, sortcode_v3, this_guide, v1, v2, v3;
            v1 = arg[0], v2 = arg[1], v3 = arg[2];
            glyph_v1 = v1[0], lineup_v1 = v1[1];
            this_guide = (Array.from(lineup_v1))[7];
            if (this_guide === last_guide) {
              return send([v1, v2, v3]);
            }
            last_guide = this_guide;
            linup = "　　　　　　|" + this_guide + "　　　　　　";
            sortcode_v3 = v3[2];
            send([[this_guide, linup], [this_guide, linup], [this_guide, linup, sortcode_v3]]);
            return send([v1, v2, v3]);
          });
        })()).pipe((function() {
          var count, for_mkts, include_sortcode, include_v1, ldiff_0, ldiff_1, nspc, rdiff_0, rdiff_1, style, vsep, wspc;
          count = 0;
          wspc = '\u3000';
          nspc = '\u3000';
          style = 'C';
          switch (style) {
            case 'A':
              vsep = '◉';
              include_v1 = false;
              include_sortcode = false;
              for_mkts = false;
              ldiff_0 = ' ';
              ldiff_1 = '<';
              rdiff_0 = ' ';
              rdiff_1 = '>';
              break;
            case 'B':
              vsep = '║';
              include_v1 = true;
              for_mkts = true;
              include_sortcode = false;
              ldiff_0 = wspc;
              ldiff_1 = '＜';
              rdiff_0 = wspc;
              rdiff_1 = '＞';
              break;
            case 'C':
              vsep = '║';
              include_v1 = true;
              for_mkts = true;
              include_sortcode = false;
              ldiff_0 = wspc;
              ldiff_1 = '＜';
              rdiff_0 = wspc;
              rdiff_1 = '＞';
              break;
            default:
              throw new Error("unknown style " + (rpr(style)));
          }
          return D.$observe(function(arg) {
            var code, diff, diff_v1, diff_v2, glyph_v1, glyph_v2, glyph_v3, i, idx, len, line, lineup_v1, lineup_v2, lineup_v3, sortcode_v3, v1, v2, v3;
            v1 = arg[0], v2 = arg[1], v3 = arg[2];
            glyph_v1 = v1[0], lineup_v1 = v1[1];
            glyph_v2 = v2[0], lineup_v2 = v2[1];
            glyph_v3 = v3[0], lineup_v3 = v3[1], sortcode_v3 = v3[2];
            if (include_sortcode) {
              for (idx = i = 0, len = sortcode_v3.length; i < len; idx = ++i) {
                code = sortcode_v3[idx];
                if (code === null) {
                  sortcode_v3[idx] = '________';
                }
              }
              sortcode_v3 = sortcode_v3.join(' ');
            }
            diff = [];
            diff_v1 = glyph_v1 === glyph_v2 ? ldiff_0 : ldiff_1;
            diff_v2 = glyph_v2 === glyph_v3 ? rdiff_0 : rdiff_1;
            if (include_v1) {
              line = lineup_v1 + nspc + glyph_v1;
              line += nspc + diff_v1 + vsep + nspc + lineup_v2 + nspc + glyph_v2;
              line += nspc + vsep + diff_v2 + nspc + lineup_v3 + nspc + glyph_v3;
            } else {
              line = lineup_v2 + nspc + glyph_v2;
              line += nspc + vsep + diff_v2 + nspc + lineup_v3 + nspc + glyph_v3;
            }
            if (for_mkts) {
              line += '<<< >>>';
              if (include_sortcode) {
                line += sortcode_v3;
              }
            } else {
              line += spc + spc + spc;
            }
            count += 1;
            if (count % 500 === 0) {
              help(ƒ(count));
            }
            return echo(line);
          });
        })());
        return null;
      };
    })(this));
  };

  this.show_codepoints_with_missing_predicates = function(v2_db, prd) {
    var $exclude_gaiji, $exclude_rare_glyphs, $extract_glyph, $fetch_v1_entries, $show, $show_progress, $test_for_predicate, home, input, prefix, rank_limit, v1_db, v1_lte_from_gte, v1_route, v2_route;
    if (prd == null) {
      prd = 'guide/kwic/v1/lineup';
    }
    home = join(__dirname, '../../jizura-datasources');
    v1_route = join(home, 'data/leveldb');
    v2_route = join(home, 'data/leveldb-v2');
    v1_db = HOLLERITH.new_db(v1_route, {
      create: false
    });
    if (v2_db == null) {
      v2_db = HOLLERITH.new_db(v2_route, {
        create: false
      });
    }
    help("using DB at " + v1_db['%self']['location']);
    help("using DB at " + v2_db['%self']['location']);
    rank_limit = 2e308;
    rank_limit = 100;
    $extract_glyph = (function(_this) {
      return function() {
        return $(function(xpos, send) {
          return send(xpos[3]);
        });
      };
    })(this);
    $exclude_gaiji = (function(_this) {
      return function() {
        return D.$filter(function(glyph) {
          return (!glyph.startsWith('&')) || (glyph.startsWith('&jzr#'));
        });
      };
    })(this);
    $show_progress = (function(_this) {
      return function() {
        var count;
        count = 0;
        return D.$observe(function() {
          count += +1;
          if (count % 10000 === 0) {
            return echo(ƒ(count));
          }
        });
      };
    })(this);
    $show = (function(_this) {
      return function() {
        return D.$observe(function(arg) {
          var glyph, i, key, keys, len, results;
          glyph = arg[0], keys = arg[1];
          echo(CHR.as_fncr(glyph, {
            input: 'xncr'
          }), CHR.as_uchr(glyph, {
            input: 'xncr'
          }));
          results = [];
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            results.push(echo('  ' + key));
          }
          return results;
        });
      };
    })(this);
    $exclude_rare_glyphs = (function(_this) {
      return function() {

        /* TAINT code duplication; factor out */
        var ranks;
        ranks = {};
        return $async(function(glyph, done) {

          /* filter out 'uncommon' glyphs (whose rank exceeds rank limit) */
          var rank, sub_prefix, sub_query;
          if (rank_limit < 0 || rank_limit === 2e308) {
            return done(glyph);
          }
          if (((rank = ranks[glyph]) != null) && rank < rank_limit) {
            return done(glyph);
          }
          sub_prefix = ['spo', glyph, 'rank/cjt'];
          sub_query = {
            prefix: sub_prefix,
            fallback: null
          };
          return HOLLERITH.read_one_phrase(v2_db, sub_query, function(error, sub_phrase) {
            var _;
            if (error != null) {
              return done.error(error);
            }
            if (sub_phrase === null) {
              ranks[glyph] = 2e308;
              return done();
            }
            _ = sub_phrase[0], _ = sub_phrase[1], _ = sub_phrase[2], rank = sub_phrase[3];
            ranks[glyph] = rank;
            if (!(rank < rank_limit)) {
              return done();
            }
            return done(glyph);
          });
        });
      };
    })(this);
    $test_for_predicate = (function(_this) {
      return function(prd) {
        return $async(function(glyph, done) {
          var sub_prefix, sub_query;
          sub_prefix = ['spo', glyph, prd];
          sub_query = {
            prefix: sub_prefix,
            fallback: null
          };
          return HOLLERITH.read_one_phrase(v2_db, sub_query, function(error, sub_phrase) {
            if (error != null) {
              return done.error(error);
            }
            if (sub_phrase === null) {
              return done(glyph);
            }
            return done();
          });
        });
      };
    })(this);
    v1_lte_from_gte = function(gte) {
      var R, last_idx;
      R = new Buffer((last_idx = Buffer.byteLength(gte)) + 1);
      R.write(gte);
      R[last_idx] = 0xff;
      return R;
    };
    $fetch_v1_entries = (function(_this) {
      return function() {
        return $async(function(glyph, done) {
          var Z, gte, lte, sub_input;
          gte = "so|glyph:" + glyph;
          lte = v1_lte_from_gte(gte);
          sub_input = v1_db['%self'].createKeyStream({
            gte: gte,
            lte: lte
          });
          Z = [];
          return sub_input.pipe($(function(key, send, end) {
            if (key != null) {
              Z.push(key.toString('utf-8'));
            }
            if (end != null) {
              end();
              return done([glyph, Z]);
            }
          }));
        });
      };
    })(this);
    prefix = {
      prefix: ['pos', 'cp/inner/original']
    };
    input = HOLLERITH.create_phrasestream(v2_db, prefix);
    input.pipe($extract_glyph()).pipe($exclude_gaiji()).pipe($test_for_predicate(prd)).pipe($fetch_v1_entries()).pipe(D.$show()).pipe($show());
    return null;
  };

  this.show_encoding_sample = function() {
    var b, encoding, i, idx, key, key_rpr, len, obj, phrases, prd, ref, sbj, value, value_rpr;
    encoding = HOLLERITH.CODEC.encodings['dbcs2'];
    encoding = HOLLERITH.CODEC.encodings['aleph'];
    encoding = HOLLERITH.CODEC.encodings['rdctn'];
    phrases = [['丁', 'strokecount', 2], ['三', 'strokecount', 3], ['夫', 'strokecount', 5], ['國', 'strokecount', 11], ['形', 'strokecount', 7], ['丁', 'componentcount', 1], ['三', 'componentcount', 1], ['夫', 'componentcount', 1], ['國', 'componentcount', 4], ['形', 'componentcount', 2], ['丁', 'components', ['丁']], ['三', 'components', ['三']], ['夫', 'components', ['夫']], ['國', 'components', ['囗', '戈', '口', '一']], ['形', 'components', ['开', '彡']]];
    for (i = 0, len = phrases.length; i < len; i++) {
      ref = phrases[i], sbj = ref[0], prd = ref[1], obj = ref[2];
      key = HOLLERITH.CODEC.encode([sbj, prd]);
      value = new Buffer(JSON.stringify(obj));
      key_rpr = ((function() {
        var j, ref1, results;
        results = [];
        for (idx = j = 0, ref1 = key.length; 0 <= ref1 ? j < ref1 : j > ref1; idx = 0 <= ref1 ? ++j : --j) {
          results.push(encoding[key[idx]]);
        }
        return results;
      })()).join('');
      value_rpr = ((function() {
        var j, ref1, results;
        results = [];
        for (idx = j = 0, ref1 = value.length; 0 <= ref1 ? j < ref1 : j > ref1; idx = 0 <= ref1 ? ++j : --j) {
          results.push(encoding[value[idx]]);
        }
        return results;
      })()).join('');
      urge(key_rpr, '┊', value_rpr);
    }
    b = new Buffer('一x丁x丂');
    return help(HOLLERITH.CODEC.rpr_of_buffer(HOLLERITH.CODEC.encode([true, -1 / 7])));
  };

  if (module.parent == null) {
    options = {
      'route': njs_path.resolve(__dirname, '../../jizura-datasources/data/leveldb-v2')
    };
    debug('©AoOAS', options);
    this.show_kwic_v2_and_v3_sample();
  }

}).call(this);

//# sourceMappingURL=demo.js.map
