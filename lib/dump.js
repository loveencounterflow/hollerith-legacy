// Generated by CoffeeScript 1.9.1
(function() {
  var $, CND, D, HOLLERITH, alert, badge, chrs, cli_options, db, debug, docopt, dump_settings, echo, filename, help, hollerith_settings, info, limit, log, new_db, prefix, rpr, urge, usage, version, warn, whisper, ƒ;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOLLERITH/dump';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams2');

  $ = D.remit.bind(D);

  new_db = require('level');

  HOLLERITH = require('./main');

  ƒ = CND.format_number.bind(CND);

  this._first_chrs_of = function(text, n) {

    /*
    for text in [ 'abc', '中國皇帝', 'a𪜄b', ]
      for n in [ 0 .. 5 ]
        debug '©DLOTs', n, rpr prefix_of text, n
     */
    var count, idx, last_idx;
    if (n <= 0) {
      return '';
    }
    count = 0;
    idx = -1;
    last_idx = text.length - 1;
    while (count < n) {
      if (idx >= last_idx) {
        break;
      }
      idx += +1;
      if ((text.codePointAt(idx)) > 0xffff) {
        idx += +1;
      }
      count += 1;
    }
    return [text.slice(0, +idx + 1 || 9e9), idx + 1];
  };

  this._type_from_key = function(db, key) {
    var first, idx, phrasetype, ref, second;
    if (Array.isArray(key)) {
      if (!((3 <= (ref = key.length) && ref <= 4))) {
        throw new Error("illegal key: " + (rpr(key)));
      }
      phrasetype = key[0], first = key[1], second = key[2], idx = key[3];
      if (phrasetype !== '<' && phrasetype !== '>') {
        throw new Error("illegal phrasetype: " + (rpr(key)));
      }
      if (!((Array.isArray(first)) && first.length === 2)) {
        throw new Error("illegal key: " + (rpr(key)));
      }
      if (!((Array.isArray(second)) && second.length === 2)) {
        throw new Error("illegal key: " + (rpr(key)));
      }
      return 'list';
    }
    return 'other';
  };

  this._rpr_of_key = function(db, key) {
    var first, idx, idx_rpr, phrasetype, second;
    if ((this._type_from_key(db, key)) === 'list') {
      phrasetype = key[0], first = key[1], second = key[2], idx = key[3];
      idx_rpr = idx != null ? rpr(idx) : '';

      /* TAINT should escape metachrs `|`, ':' */

      /* TAINT should use `rpr` on parts of speech (e.g. object value could be a number etc.) */
      return "" + phrasetype + (first.join(':')) + "|" + (second.join(':')) + "|" + idx_rpr;
    }
    return "" + (rpr(key));
  };


  /* TAINT code duplication */

  this._$dump_keys = function(db, input, settings) {
    var chrs, colors, count, limit;
    limit = settings.limit, colors = settings.colors, chrs = settings.chrs;
    count = 0;
    return $((function(_this) {
      return function(key, send, end) {
        var key_rpr;
        if (key != null) {
          count += +1;
          if (count < limit) {
            key_rpr = _this._rpr_of_key(db, HOLLERITH._decode(db, key));
            if (colors) {
              log(CND.grey(ƒ(count)), CND.plum(key_rpr), CND.grey(key.slice(0, 10)));
            } else {
              echo(ƒ(count), key);
            }
            send(key);
          }
          if (count >= limit) {
            input.emit('end');
          }
        }
        if (end != null) {
          help("dumped " + (ƒ(count)) + " entries");
          return process.exit();
        }
      };
    })(this));
  };


  /* TAINT code duplication */

  this._$dump_prefixes = function(db, input, settings) {
    var chrs, colors, key_count, limit, prefix_count, prefixes, t0;
    limit = settings.limit, colors = settings.colors, chrs = settings.chrs;
    key_count = 0;
    prefix_count = 0;
    prefixes = {};
    t0 = +new Date();
    return $((function(_this) {
      return function(key, send, end) {
        var dt, dt_min, dt_s, key_rpr, prefix, ref, suffix_idx, t1;
        if (key != null) {
          key_count += +1;
          if (key_count < limit) {
            key_rpr = _this._rpr_of_key(db, HOLLERITH._decode(db, key));
            ref = _this._first_chrs_of(key_rpr, chrs), prefix = ref[0], suffix_idx = ref[1];
            if (prefixes[prefix] == null) {
              prefix_count += +1;
              prefixes[prefix] = 1;
              if (colors) {
                log(CND.grey(ƒ(key_count)), (CND.plum(prefix)) + (CND.grey(key_rpr.slice(suffix_idx))));
              } else {
                echo(ƒ(key_count), prefix, key_rpr.slice(suffix_idx));
              }
              send(key);
            }
          }
          if (key_count >= limit) {
            input.emit('end');
          }
        }
        if (end != null) {
          t1 = +new Date();
          dt = t1 - t0;
          dt_s = (dt / 1000).toFixed(3);
          dt_min = (dt / 60000).toFixed(1);
          help("dumped " + (ƒ(key_count)) + " entries in " + dt_s + "s (" + dt_min + "min)");
          help("found " + (ƒ(prefix_count)) + " distinct prefixes with up to " + (ƒ(chrs)) + " characters");
          return process.exit();
        }
      };
    })(this));
  };

  this.dump = function(db, settings) {
    var input, mode, prefix, query, worker;
    mode = settings.mode, prefix = settings.prefix;
    switch (settings['mode']) {
      case 'keys':
        if (prefix != null) {
          query = HOLLERITH._query_from_prefix(db, [prefix]);
          urge('©g1y6J', HOLLERITH._encode(db, [prefix]));
          urge('©g1y6J', query['gte']);
          urge('©g1y6J', query['lte']);
          input = db['%self'].createKeyStream(query);
        } else {
          input = db['%self'].createKeyStream();
        }
        worker = this._$dump_keys(db, input, settings);
        break;
      case 'prefixes':
        input = db['%self'].createKeyStream();
        worker = this._$dump_prefixes(db, input, settings);
        break;
      default:
        throw new Error("unknown mode " + (rpr(mode)));
    }
    return input.pipe(worker);
  };

  if (module.parent == null) {
    hollerith_settings = {
      'route': '/tmp/leveldb'
    };
    docopt = (require('coffeenode-docopt')).docopt;
    version = (require('../package.json'))['version'];
    filename = (require('path')).basename(__filename);
    usage = "Usage: " + filename + " [--limit=N]\n       " + filename + " ( [<prefix>] | keys [<prefix>] | prefixes [<chrs>] ) [--limit=N]\n\nOptions:\n  -l, --limit\n  -h, --help\n  -v, --version";

    /*
           #{filename} pos [--sample]
           #{filename} so [--db] [--limit] [--stdout] [<prefix>]
           #{filename} os [--db] [--limit] [--stdout] [<prefix>]
           #{filename} x
           #{filename} y
           #{filename} q <query0> [+|-] <query1>
           #{filename} sql
           #{filename} count
     */
    cli_options = docopt(usage, {
      version: version,
      help: function(left, collected) {
        urge(left);
        help(collected);
        help('\n' + usage);
        return process.exit();
      }
    });
    dump_settings = {
      limit: Infinity,
      mode: 'keys',
      colors: process.stdout.isTTY ? true : false,
      chrs: 3
    };
    if ((limit = cli_options['--limit'])) {
      dump_settings['limit'] = parseInt(limit, 10);
    }
    if (cli_options['prefixes']) {
      dump_settings['mode'] = 'prefixes';
    }
    if ((chrs = cli_options['<chrs>'])) {
      dump_settings['chrs'] = parseInt(chrs, 10);
    }
    if ((prefix = cli_options['<prefix>']) != null) {
      dump_settings['prefix'] = prefix;
    }
    db = HOLLERITH.new_db(hollerith_settings['route']);
    this.dump(db, dump_settings);
    debug('©lJ8nb', HOLLERITH._encode(null, 1));
    debug('©lJ8nb', HOLLERITH._encode(null, [1]));
    debug('©lJ8nb', HOLLERITH._encode(null, [1, void 0]));
    log();
    debug('©lJ8nb', HOLLERITH._encode(null, '1'));
    debug('©lJ8nb', HOLLERITH._encode(null, ['1']));
    debug('©lJ8nb', HOLLERITH._query_from_prefix(null, 1));
    debug('©lJ8nb', HOLLERITH._query_from_prefix(null, [1]));
    debug('©lJ8nb', HOLLERITH._query_from_prefix(null, '1'));
    debug('©lJ8nb', HOLLERITH._query_from_prefix(null, ['1']));
    debug('©lJ8nb', HOLLERITH._encode(null, '\x00'));
    debug('©lJ8nb', HOLLERITH._encode(null, '\x01'));
    debug('©lJ8nb', HOLLERITH._encode(null, '\x02'));
    log();
  }

}).call(this);
