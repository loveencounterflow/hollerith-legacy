// Generated by CoffeeScript 1.10.0
(function() {
  var $, CND, D, DUMP, HOLLERITH, alert, app, app_name, badge, debug, echo, get_boolean, help, info, is_tty, join, log, new_db, njs_path, ref, rpr, urge, warn, whisper, ƒ;

  njs_path = require('path');

  join = njs_path.join;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HOLLERITH/dump';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.remit.bind(D);

  new_db = require('level');

  HOLLERITH = require('./main');

  ƒ = CND.format_number.bind(CND);

  this._first_chrs_of = function(text, n) {

    /*
    for text in [ 'abc', '中國皇帝', 'a𪜄b', ]
      for n in [ 0 .. 5 ]
        debug '©DLOTs', n, rpr prefix_of text, n
     */
    var count, idx, last_idx;
    if (n <= 0) {
      return '';
    }
    count = 0;
    idx = -1;
    last_idx = text.length - 1;
    while (count < n) {
      if (idx >= last_idx) {
        break;
      }
      idx += +1;
      if ((text.codePointAt(idx)) > 0xffff) {
        idx += +1;
      }
      count += 1;
    }
    return [text.slice(0, +idx + 1 || 9e9), idx + 1];
  };


  /* TAINT code duplication */

  this._$dump_facets = function(db, input, settings) {
    var chrs, colors, count, limit, write;
    limit = settings.limit, colors = settings.colors, chrs = settings.chrs;
    count = 0;
    write = colors ? log : echo;
    return $((function(_this) {
      return function(facet, send, end) {
        var count_txt, error, error1, key_bfr, key_rpr, value_bfr;
        if (facet != null) {
          count += +1;
          key_bfr = facet.key, value_bfr = facet.value;
          if (count < limit) {
            if (HOLLERITH._is_meta(db, key_bfr)) {
              warn("skipped meta: " + (rpr(key_bfr.toString())));
            } else {
              try {
                key_rpr = HOLLERITH.as_url(db, key_bfr, value_bfr, {
                  colors: colors
                });
              } catch (error1) {
                error = error1;
                key_rpr = (CND.green(HOLLERITH.CODEC.rpr_of_buffer(key_bfr))) + '\n  ' + (CND.orange(HOLLERITH.CODEC.rpr_of_buffer(value_bfr))) + '\n  ' + (CND.red(rpr(error)));
              }
              count_txt = colors ? CND.grey(ƒ(count)) : ƒ(count);
              write(count_txt, key_rpr);
              send(key_bfr);
            }
          }
          if (count >= limit) {
            input.emit('end');
          }
        }
        if (end != null) {
          help("dumped " + (ƒ(count)) + " entries");
          return process.exit();
        }
      };
    })(this));
  };

  this.dump = function(db, settings) {
    var input, mode, n, prefix, query, star;
    mode = settings.mode, prefix = settings.prefix;
    prefix = prefix.split(/\||:/);
    star = null;
    if (prefix[prefix.length - 1] === '*') {
      prefix.pop();
      star = '*';
    }
    if (prefix[2] === '-') {
      prefix[2] = null;
    } else if (CND.isa_number((n = parseInt(prefix[2], 10)))) {
      prefix[2] = n;
    }
    query = star != null ? {
      prefix: prefix,
      star: star
    } : {
      prefix: prefix
    };
    input = HOLLERITH.create_phrasestream(db, query);
    urge("query: " + (rpr(query)));
    input.pipe(D.$count((function(_this) {
      return function(count) {
        return help("read " + count + " keys");
      };
    })(this))).pipe(D.$observe((function(_this) {
      return function(data) {
        return echo(JSON.stringify(data));
      };
    })(this)));
    return null;
  };

  this.rpr_of_facets = function(db, facets, encoding) {
    var a, b, columnify_settings, i, j, key, key_rpr, len, len1, ref, ref1, value, value_rpr;
    columnify_settings = {
      paddingChr: ' ',
      columnSplitter: ' ┊ '
    };
    a = [];
    b = [];
    for (i = 0, len = facets.length; i < len; i++) {
      ref = facets[i], key = ref[0], value = ref[1];
      key_rpr = (rpr(key)).replace(/^<Buffer (.*)>$/, '$1');
      value_rpr = (rpr(value)).replace(/^<Buffer (.*)>$/, '$1');
      a.push([key_rpr, value_rpr]);
    }
    a = CND.columnify(a, columnify_settings);
    for (j = 0, len1 = facets.length; j < len1; j++) {
      ref1 = facets[j], key = ref1[0], value = ref1[1];
      key_rpr = HOLLERITH.CODEC._encode_buffer(db, key, encoding);
      value_rpr = HOLLERITH.CODEC._encode_buffer(db, value, encoding);
      b.push([key_rpr, value_rpr]);
    }
    b = CND.columnify(b, columnify_settings);
    return a + '\n' + b;
  };

  if (module.parent == null) {
    app = require('commander');
    app_name = process.argv[1];
    app.version((require('../package.json'))['version']);
    is_tty = process.stdout.isTTY;
    DUMP = this;
    get_boolean = function(input, fallback) {
      if (fallback == null) {
        fallback = false;
      }
      if (input == null) {
        return fallback;
      }
      return input;
    };
    app.command("dump [db_route] [prefix]").description("dump values in DB").option("--limit [n]", "limit output to n entries").option("--json", "format values as JSON").action(function(route, prefix, options) {
      var S, db, dump_settings, json, limit, ref, ref1;
      limit = (ref = options['limit']) != null ? ref : null;
      if (limit != null) {
        limit = parseInt(limit, 10);
      }
      json = (ref1 = options['json']) != null ? ref1 : false;
      S = {
        command: 'dump',
        mode: 'keys',
        colors: process.stdout.isTTY ? true : false,
        limit: limit,
        json: json,
        route: route,
        prefix: prefix
      };
      help(S);
      dump_settings = {
        limit: Infinity,
        mode: 'keys',
        colors: process.stdout.isTTY ? true : false,
        chrs: 3
      };
      db = HOLLERITH.new_db(S['route'], {
        create: false
      });
      help("using LevelDB at " + S['route']);
      DUMP.dump(db, S);
      return null;
    });
    app.parse(process.argv);
    if (!(((ref = app.args) != null ? ref.length : void 0) > 0)) {
      warn("missing arguments");
      app.help();
    }
  }

}).call(this);

//# sourceMappingURL=dump.js.map
