{"version":3,"sources":["tests.coffee"],"names":[],"mappings":"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","file":"tests.js","sourceRoot":"/source/","sourcesContent":["\n\n\n############################################################################################################\nnjs_path                  = require 'path'\n# njs_fs                    = require 'fs'\njoin                      = njs_path.join\n#...........................................................................................................\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'HOLLERITH/tests'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nsuspend                   = require 'coffeenode-suspend'\nstep                      = suspend.step\nafter                     = suspend.after\n# eventually                = suspend.eventually\nimmediately               = suspend.immediately\n# repeat_immediately        = suspend.repeat_immediately\n# every                     = suspend.every\n#...........................................................................................................\ntest                      = require 'guy-test'\n#...........................................................................................................\nD                         = require 'pipedreams2'\n$                         = D.remit.bind D\n$async                    = D.remit_async.bind D\n#...........................................................................................................\nHOLLERITH                 = require './main'\ndb                        = null\n#...........................................................................................................\nlevelup                   = require 'level'\nleveldown                 = require 'level/node_modules/leveldown'\nCODEC                     = require './codec'\n#...........................................................................................................\nƒ                         = CND.format_number\n\n# #-----------------------------------------------------------------------------------------------------------\n# @_sort_list = ( list ) ->\n#   @_encode_list list\n#   list.sort Buffer.compare\n#   @_decode_list list\n#   return list\n\n#-----------------------------------------------------------------------------------------------------------\n@_feed_test_data = ( db, probes_idx, settings, handler ) ->\n  switch arity = arguments.length\n    when 3\n      handler   = settings\n      settings  = null\n    when 4\n      null\n    else\n      throw new Error \"expected 3 or 4 arguments, got #{arity}\"\n  #.........................................................................................................\n  step ( resume ) =>\n    yield HOLLERITH.clear db, resume\n    whisper \"writing test dataset ##{probes_idx} with settings #{rpr settings}\"\n    input = D.create_throughstream()\n    #.......................................................................................................\n    switch probes_idx\n      #-----------------------------------------------------------------------------------------------------\n      when 0, 2, 3, 4\n        input\n          .pipe HOLLERITH.$write db, settings\n          # .pipe D.$show()\n          .pipe D.$on_end ( end ) =>\n            whisper \"test data written\"\n            handler null\n            end()\n        #...................................................................................................\n        for probe in @_feed_test_data.probes[ probes_idx ]\n          # key = HOLLERITH.new_so_key db, probe...\n          # debug '©WV0j2', probe\n          input.write probe\n          yield setImmediate resume\n        input.end()\n      #-----------------------------------------------------------------------------------------------------\n      when 1\n        input\n          .pipe HOLLERITH.$write db, settings\n          # .pipe D.$show()\n          .pipe D.$on_end ( end ) =>\n            whisper \"test data written\"\n            end()\n            handler null\n        #...................................................................................................\n        for url_key in @_feed_test_data.probes[ probes_idx ]\n          key = HOLLERITH.key_from_url db, url_key\n          input.write key\n          yield setImmediate resume\n        input.end()\n      #-------------------------------------------------------------------------------------------------------\n      else return handler new Error \"illegal probes index #{rpr probes_idx}\"\n  #.........................................................................................................\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\n@_feed_test_data.probes = []\n\n#...........................................................................................................\n### probes_idx == 0 ###\n@_feed_test_data.probes.push [\n  [ '𧷟1', 'guide/lineup/length',              1,                                   ]\n  [ '𧷟2', 'guide/lineup/length',              2,                                   ]\n  [ '𧷟3', 'guide/lineup/length',              3,                                   ]\n  [ '𧷟4', 'guide/lineup/length',              4,                                   ]\n  [ '𧷟', 'guide/lineup/length',               5,                                   ]\n  [ '𧷟6', 'guide/lineup/length',              6,                                   ]\n  [ '𧷟', 'cp/cid',                           163295,                               ]\n  [ '𧷟', 'guide/uchr/has',                   [ '八', '刀', '宀', '', '貝', ],      ]\n  [ '𧷟', 'rank/cjt',                         5432,                                 ]\n  [ '八', 'factor/strokeclass/wbf',          '34',                                  ]\n  [ '刀', 'factor/strokeclass/wbf',          '5(12)3',                              ]\n  [ '宀', 'factor/strokeclass/wbf',          '44',                                  ]\n  [ '', 'factor/strokeclass/wbf',          '12',                                  ]\n  [ '貝', 'factor/strokeclass/wbf',          '25(12)',                              ]\n  [ '八', 'rank/cjt',                         12541,                                ]\n  [ '刀', 'rank/cjt',                         12542,                                ]\n  [ '宀', 'rank/cjt',                         12543,                                ]\n  [ '', 'rank/cjt',                         12544,                                ]\n  [ '貝', 'rank/cjt',                         12545,                                ]\n  ]\n\n#...........................................................................................................\n### probes_idx == 1 ###\n@_feed_test_data.probes.push [\n  'so|glyph:劬|cp/fncr:u-cjk/52ac|0'\n  'so|glyph:邭|cp/fncr:u-cjk/90ad|0'\n  'so|glyph:𠴦|cp/fncr:u-cjk-xb/20d26|0'\n  'so|glyph:𤿯|cp/fncr:u-cjk-xb/24fef|0'\n  'so|glyph:𧑴|cp/fncr:u-cjk-xb/27474|0'\n  'so|glyph:𨒡|cp/fncr:u-cjk-xb/284a1|0'\n  'so|glyph:𪚧|cp/fncr:u-cjk-xb/2a6a7|0'\n  'so|glyph:𪚫|cp/fncr:u-cjk-xb/2a6ab|0'\n  'so|glyph:𤿯|strokeorder:352513553254|0'\n  'so|glyph:𠴦|strokeorder:3525141121|0'\n  'so|glyph:𨒡|strokeorder:35251454|0'\n  'so|glyph:邭|strokeorder:3525152|0'\n  'so|glyph:𪚫|strokeorder:352515251115115113541|0'\n  'so|glyph:𪚧|strokeorder:35251525112511511|0'\n  'so|glyph:𧑴|strokeorder:352515251214251214|0'\n  'so|glyph:劬|strokeorder:3525153|0'\n  ]\n\n#-----------------------------------------------------------------------------------------------------------\n### probes_idx == 2 ###\n@_feed_test_data.probes.push [\n  [ '丁', 'strokecount',     2,                          ]\n  [ '三', 'strokecount',     3,                          ]\n  [ '夫', 'strokecount',     5,                          ]\n  [ '國', 'strokecount',     11,                         ]\n  [ '形', 'strokecount',     7,                          ]\n  [ '丁', 'componentcount',  1,                          ]\n  [ '三', 'componentcount',  1,                          ]\n  [ '夫', 'componentcount',  1,                          ]\n  [ '國', 'componentcount',  4,                          ]\n  [ '形', 'componentcount',  2,                          ]\n  [ '丁', 'components',      [ '丁', ],                  ]\n  [ '三', 'components',      [ '三', ],                  ]\n  [ '夫', 'components',      [ '夫', ],                  ]\n  [ '國', 'components',      [ '囗', '戈', '口', '一', ], ]\n  [ '形', 'components',      [ '开', '彡', ],             ]\n  ]\n\n#-----------------------------------------------------------------------------------------------------------\n### probes_idx == 3 ###\n@_feed_test_data.probes.push [\n  [ '丁', 'isa',                         [ 'glyph', 'guide', ]       ]\n  [ '三', 'isa',                         [ 'glyph', 'guide', ]       ]\n  [ '夫', 'isa',                         [ 'glyph', 'guide', ]       ]\n  [ '國', 'isa',                         [ 'glyph', ]                ]\n  [ '形', 'isa',                         [ 'glyph', ]                ]\n  [ 'glyph:丁', 'strokeorder/count',     2,                          ]\n  [ 'glyph:三', 'strokeorder/count',     3,                          ]\n  [ 'glyph:夫', 'strokeorder/count',     5,                          ]\n  [ 'glyph:國', 'strokeorder/count',     11,                         ]\n  [ 'glyph:形', 'strokeorder/count',     7,                          ]\n  [ 'glyph:丁', 'guide/count',           1,                          ]\n  [ 'glyph:三', 'guide/count',           1,                          ]\n  [ 'glyph:夫', 'guide/count',           1,                          ]\n  [ 'glyph:國', 'guide/count',           4,                          ]\n  [ 'glyph:形', 'guide/count',           2,                          ]\n  [ 'glyph:丁', 'guide/lineup',          [ '丁', ],                  ]\n  [ 'glyph:三', 'guide/lineup',          [ '三', ],                  ]\n  [ 'glyph:夫', 'guide/lineup',          [ '夫', ],                  ]\n  [ 'glyph:國', 'guide/lineup',          [ '囗', '戈', '口', '一', ], ]\n  [ 'glyph:形', 'guide/lineup',          [ '开', '彡', ],             ]\n  ]\n\n#...........................................................................................................\n### probes_idx == 4 ###\n@_feed_test_data.probes.push [\n  [ '𧷟1', 'guide/lineup/length',              1,                                   ]\n  [ '𧷟2', 'guide/lineup/length',              2,                                   ]\n  [ '𧷟3', 'guide/lineup/length',              3,                                   ]\n  [ '𧷟4', 'guide/lineup/length',              4,                                   ]\n  [ '𧷟', 'guide/lineup/length',               5,                                   ]\n  [ '𧷟6', 'guide/lineup/length',              6,                                   ]\n  [ '𧷟', 'cp/cid',                           163295,                               ]\n  [ '𧷟', 'guide/uchr/has',                   [ '八', '刀', '宀', '', '貝', ],      ]\n  [ '𧷟', 'rank/cjt',                         5432,                                 ]\n  [ '八', 'factor/strokeclass/wbf',          '34',                                  ]\n  [ '刀', 'factor/strokeclass/wbf',          '5(12)3',                              ]\n  [ '宀', 'factor/strokeclass/wbf',          '44',                                  ]\n  [ '', 'factor/strokeclass/wbf',          '12',                                  ]\n  [ '貝', 'factor/strokeclass/wbf',          '25(12)',                              ]\n  [ '八', 'rank/cjt',                         12541,                                ]\n  [ '刀', 'rank/cjt',                         12542,                                ]\n  [ '宀', 'rank/cjt',                         12543,                                ]\n  [ '', 'rank/cjt',                         12544,                                ]\n  [ '貝', 'rank/cjt',                         12545,                                ]\n  [ '𧷟1', 'a', 42 ]\n  [ '𧷟1', 'ab', 42 ]\n  [ '𧷟1', 'guide', 'xxx' ]\n  [ '𧷟1', 'guide/', 'yyy' ]\n  [ '𧷟1', 'z', 42 ]\n  ]\n\n# pos|guide/kwic/sortcode\n\n# # [\n# # \"1027~~~~,00\",\"0156~~~~,01,0509~~~~,02,0000~~~~,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,\"\n# # \"0156~~~~,01\",\"0509~~~~,02,0000~~~~,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,1027~~~~,00,\"\n# # \"0509~~~~,02\",\"0000~~~~,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,1027~~~~,00,0156~~~~,01,\"\n# # \"0000~~~~,03\",\"--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,1027~~~~,00,0156~~~~,01,0509~~~~,02,\"\n# # ]\n\n# 0087~~~~,00,0291~~~~,01,0555~~~~,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦖈|0\n# 0087~~~~,00,0291~~~~,01,0823x2h-,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|聗|0\n# 0087~~~~,00,0291~~~~,01,1023~~~~,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𤋕|0\n# 0087~~~~,00,0294~~~~,01,0060~~~~,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦖔|0\n# 0087~~~~,00,0294~~~~,01,0555~~~~,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦗆|0\n# 0087~~~~,00,0295~~~~,01,0802~~~~,02,0958~~~~,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𥪻|0\n# 0087~~~~,00,0312~~~~,01,--------,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦔲|0\n# 0087~~~~,00,0314~~~~,01,1173~~~~,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦕀|0\n# 0087~~~~,00,0319~~~~,01,--------,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦕇|0\n# 0087~~~~,00,0355~~~~,01,--------,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦕆|0\n# 0087~~~~,00,0373~~~~,01,0284~~~~,02,--------,03,--------,04,--------,05,--------,06,--------,07,--------,08,--------,09,--------,10,--------,11,--------,12,|𦕧|0\n\n#-----------------------------------------------------------------------------------------------------------\n@[ \"write without error\" ] = ( T, done ) ->\n  probes_idx  = 0\n  idx = -1\n  write_settings =\n    batch: 10\n  step ( resume ) =>\n    yield @_feed_test_data db, probes_idx, write_settings, resume\n    done()\n\n#-----------------------------------------------------------------------------------------------------------\n@[ \"read without error\" ] = ( T, done ) ->\n  probes_idx  = 0\n  idx = -1\n  step ( resume ) =>\n    debug '©7lEgy', db['%self'].isClosed()\n    debug '©7lEgy', db['%self'].isOpen()\n    yield @_feed_test_data db, probes_idx, resume\n    # done()\n    input = HOLLERITH.create_facetstream db\n    input\n      # .pipe HOLLERITH.$url_from_key db\n      .pipe $ ( [ key, value, ], send ) =>\n        idx += +1\n        # T.eq key, matchers[ idx ]\n      .pipe D.$on_end ( end ) => end; done()\n\n#-----------------------------------------------------------------------------------------------------------\n@[ \"read keys without error (1)\" ] = ( T, done ) ->\n  step ( resume ) =>\n    yield HOLLERITH.clear db, resume\n    ### TAINT awaiting better solution ###\n    NULL = HOLLERITH._encode_value db, 1\n    for idx in [ 0 ... 10 ]\n      db[ '%self' ].put ( HOLLERITH._encode_key db, [ 'x', idx, 'x', ] ), NULL\n    #.......................................................................................................\n    probe_idx = 4\n    count     = 0\n    query     = HOLLERITH._query_from_prefix db, [ 'x', probe_idx, ]\n    input     = db[ '%self' ].createReadStream query\n    input\n      .pipe $ ( { key, value, }, send ) =>\n        count += 1\n        T.eq ( HOLLERITH._decode_key db, key )[ 1 ], probe_idx\n      .pipe D.$on_end ( end ) =>\n        T.eq count, 1\n        end()\n        done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read keys without error (2)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     yield HOLLERITH.clear db, resume\n#     ### TAINT awaiting better solution ###\n#     NULL = HOLLERITH._encode_value db, 1\n#     for idx in [ 0 ... 10 ]\n#       db[ '%self' ].put ( HOLLERITH._encode_key db, [ 'x', idx, 'x', ] ), NULL\n#     #.......................................................................................................\n#     probe_idx = 4\n#     count     = 0\n#     prefix    = [ 'x', probe_idx, ]\n#     input     = HOLLERITH.create_facetstream db, { prefix, }\n#     input\n#       .pipe $ ( facet, send ) =>\n#         count += 1\n#         [ key, value, ] = facet\n#         T.eq key[ 1 ], probe_idx\n#       .pipe D.$on_end ( end ) =>\n#         T.eq count, 1\n#         end()\n#         done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read keys without error (3)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     yield HOLLERITH.clear db, resume\n#     ### TAINT awaiting better solution ###\n#     NULL = HOLLERITH._encode_value db, 1\n#     for idx in [ 0 ... 10 ]\n#       db[ '%self' ].put ( HOLLERITH._encode_key db, [ 'x', idx, 'x', ] ), NULL\n#     #.......................................................................................................\n#     probe_idx = 3\n#     count     = 0\n#     delta     = 2\n#     lo        = [ 'x', probe_idx, ]\n#     hi        = [ 'x', probe_idx + delta, ]\n#     query     = { gte: ( HOLLERITH._encode_key db, lo ), lte: ( HOLLERITH._query_from_prefix db, hi )[ 'lte' ], }\n#     input     = db[ '%self' ].createReadStream query\n#     input\n#       .pipe $ ( { key, value, }, send ) =>\n#         count += 1\n#         T.eq ( HOLLERITH._decode_key db, key )[ 1 ], probe_idx + count - 1\n#       .pipe D.$on_end ( end ) =>\n#         T.eq count, delta + 1\n#         end()\n#         done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read keys without error (4)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     yield HOLLERITH.clear db, resume\n#     for idx in [ 0 ... 10 ]\n#       db[ '%self' ].put ( HOLLERITH._encode_key db, [ 'x', idx, 'x', ] ), HOLLERITH._encode_value db, 1\n#     #.......................................................................................................\n#     probe_idx = 3\n#     count     = 0\n#     delta     = 2\n#     lo        = [ 'x', probe_idx, ]\n#     hi        = [ 'x', probe_idx + delta, ]\n#     input     = HOLLERITH.create_facetstream db, { lo, hi, }\n#     input\n#       .pipe $ ( [ key, value, ], send ) =>\n#         count += 1\n#         T.eq key[ 1 ], probe_idx + count - 1\n#       .pipe D.$on_end ( end ) =>\n#         T.eq count, delta + 1\n#         end()\n#         done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"create_facetstream throws with wrong arguments\" ] = ( T, done ) ->\n#   message = \"illegal to specify `hi` but not `lo`\"\n#   T.throws message, ( -> HOLLERITH.create_facetstream db, hi: [ 'xxx', ] )\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read POS facets\" ] = ( T, done ) ->\n#   probes_idx  = 0\n#   idx         = -1\n#   #.........................................................................................................\n#   key_matchers = [\n#     [ 'pos', 'guide/lineup/length', 2, '𧷟2', ]\n#     [ 'pos', 'guide/lineup/length', 3, '𧷟3', ]\n#     [ 'pos', 'guide/lineup/length', 4, '𧷟4', ]\n#     ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     lo = [ 'pos', 'guide/lineup/length', 2, ]\n#     hi = [ 'pos', 'guide/lineup/length', 4, ]\n#     # input   = HOLLERITH.create_keystream db, lo\n#     input   = HOLLERITH.create_facetstream db, { lo, hi, }\n#     input\n#       # .pipe HOLLERITH.$url_from_key db\n#       .pipe $ ( [ key, value, ], send ) =>\n#         idx += +1\n#         phrase = HOLLERITH.as_phrase db, key, value\n#         T.eq key, key_matchers[ idx ]\n#       .pipe D.$on_end ( end ) => end(); done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read POS phrases (1)\" ] = ( T, done ) ->\n#   probes_idx  = 0\n#   idx         = -1\n#   #.........................................................................................................\n#   matchers = [\n#     [ 'pos', 'guide/lineup/length', 2, '𧷟2', ]\n#     [ 'pos', 'guide/lineup/length', 3, '𧷟3', ]\n#     [ 'pos', 'guide/lineup/length', 4, '𧷟4', ]\n#     ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     lo = [ 'pos', 'guide/lineup/length', 2, ]\n#     hi = [ 'pos', 'guide/lineup/length', 4, ]\n#     input   = HOLLERITH.create_phrasestream db, { lo, hi, }\n#     input\n#       .pipe $ ( phrase, send ) =>\n#         idx += +1\n#         T.eq phrase, matchers[ idx ]\n#       .pipe D.$on_end ( end ) => end(); done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read POS phrases (2)\" ] = ( T, done ) ->\n#   probes_idx  = 0\n#   idx         = -1\n#   count       = 0\n#   #.........................................................................................................\n#   matchers = [\n#     [ 'pos', 'guide/uchr/has', '八', '𧷟', 0, ]\n#     [ 'pos', 'guide/uchr/has', '刀', '𧷟', 1, ]\n#     [ 'pos', 'guide/uchr/has', '宀', '𧷟', 2, ]\n#     [ 'pos', 'guide/uchr/has', '貝', '𧷟', 4, ]\n#     [ 'pos', 'guide/uchr/has', '', '𧷟', 3, ]\n#     ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     prefix    = [ 'pos', 'guide/uchr/has', ]\n#     input     = HOLLERITH.create_phrasestream db, { prefix, }\n#     settings  = { indexed: no, }\n#     input\n#       .pipe $ ( phrase, send ) =>\n#         debug '©DsAfY', rpr phrase\n#         count  += +1\n#         idx    += +1\n#         T.eq phrase, matchers[ idx ]\n#       .pipe D.$on_end ( end ) =>\n#         T.eq count, matchers.length\n#         end()\n#         done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read SPO phrases\" ] = ( T, done ) ->\n#   debug '©Rsoxb', db[ '%self' ].isOpen()\n#   probes_idx  = 0\n#   idx         = -1\n#   count       = 0\n#   #.........................................................................................................\n#   matchers = [\n#     [ 'spo', '𧷟', 'cp/cid', 163295 ]\n#     [ 'spo', '𧷟', 'guide/lineup/length', 5 ]\n#     [ 'spo', '𧷟', 'guide/uchr/has', [ '八', '刀', '宀', '', '貝' ] ]\n#     [ 'spo', '𧷟', 'rank/cjt', 5432 ]\n#     ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     prefix  = [ 'spo', '𧷟', ]\n#     input   = HOLLERITH.create_phrasestream db, { prefix, }\n#     input\n#       .pipe $ ( phrase, send ) =>\n#         debug '©DsAfY', rpr phrase\n#         count  += +1\n#         idx    += +1\n#         T.eq phrase, matchers[ idx ]\n#       .pipe D.$on_end ( end ) =>\n#         T.eq count, matchers.length\n#         end()\n#         done()\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"read with sub-read (1)\" ] = ( T, done ) ->\n# #   probes_idx  = 0\n# #   idx         = -1\n# #   count       = 0\n# #   #.........................................................................................................\n# #   matchers = [\n# #     [ '𧷟', [ 'spo', '八', 'factor/strokeclass/wbf', '34' ] ]\n# #     ]\n# #   #.........................................................................................................\n# #   step ( resume ) =>\n# #     yield @_feed_test_data db, probes_idx, resume\n# #     prefix    = [ 'spo', '𧷟', 'guide/uchr/has', ]\n# #     input     = HOLLERITH.create_phrasestream db, { prefix, }\n# #     settings  = { indexed: no, }\n# #     input\n# #       .pipe HOLLERITH.read_sub db, settings, ( [ phrasetype, glyph, prd, guides, ] ) =>\n# #         sub_prefix  = [ 'spo', guides[ 0 ], 'factor/strokeclass/wbf', ]\n# #         sub_input   = HOLLERITH.create_phrasestream db, { prefix: sub_prefix, }\n# #         return [ glyph, sub_input, ]\n# #       .pipe $ ( phrase, send ) =>\n# #         count  += +1\n# #         idx    += +1\n# #         T.eq phrase, matchers[ idx ]\n# #       .pipe D.$on_end ( end ) =>\n# #         T.eq count, matchers.length\n# #         end()\n# #         done()\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"read with sub-read (2)\" ] = ( T, done ) ->\n# #   probes_idx  = 0\n# #   idx         = -1\n# #   count       = 0\n# #   #.........................................................................................................\n# #   matchers = [\n# #     [ '𧷟', [ 'spo', '八', 'factor/strokeclass/wbf', '34' ] ]\n# #     [ '𧷟', [ 'spo', '刀', 'factor/strokeclass/wbf', '5(12)3' ] ]\n# #     [ '𧷟', [ 'spo', '宀', 'factor/strokeclass/wbf', '44' ] ]\n# #     [ '𧷟', [ 'spo', '貝', 'factor/strokeclass/wbf', '25(12)' ] ]\n# #     [ '𧷟', [ 'spo', '', 'factor/strokeclass/wbf', '12' ] ]\n# #     ]\n# #   #.........................................................................................................\n# #   step ( resume ) =>\n# #     yield @_feed_test_data db, probes_idx, resume\n# #     prefix    = [ 'pos', 'guide/uchr/has', ]\n# #     input     = HOLLERITH.create_phrasestream db, { prefix, }\n# #     settings  = { indexed: no, }\n# #     input\n# #       .pipe HOLLERITH.read_sub db, settings, ( phrase ) =>\n# #         [ _, glyph, prd, guide, ] = phrase\n# #         prefix                    = [ 'spo', guide, 'factor/strokeclass/wbf', ]\n# #         sub_input                 = HOLLERITH.create_phrasestream db, { prefix, }\n# #         return [ glyph, sub_input, ]\n# #       .pipe $ ( phrase, send ) =>\n# #         debug '©quPbg', JSON.stringify phrase\n# #         count  += +1\n# #         idx    += +1\n# #         T.eq phrase, matchers[ idx ]\n# #       .pipe D.$on_end ( end ) =>\n# #         T.eq count, matchers.length\n# #         end()\n# #         done()\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"read with sub-read (3)\" ] = ( T, done ) ->\n# #   step ( resume ) =>\n# #     yield @_read_with_sub_read_3 T, batch: 0,    resume\n# #     yield @_read_with_sub_read_3 T, batch: 3,    resume\n# #     yield @_read_with_sub_read_3 T, batch: 5,    resume\n# #     yield @_read_with_sub_read_3 T, batch: 1000, resume\n# #     done()\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @_read_with_sub_read_3 = ( T, write_settings, done ) ->\n# #   probes_idx  = 0\n# #   idx         = -1\n# #   count       = 0\n# #   #.........................................................................................................\n# #   matchers = [\n# #     [[\"𧷟\",\"八\",\"34\"],      [\"spo\",\"八\",\"rank/cjt\",12541]]\n# #     [[\"𧷟\",\"刀\",\"5(12)3\"],  [\"spo\",\"刀\",\"rank/cjt\",12542]]\n# #     [[\"𧷟\",\"宀\",\"44\"],      [\"spo\",\"宀\",\"rank/cjt\",12543]]\n# #     [[\"𧷟\",\"貝\",\"25(12)\"],  [\"spo\",\"貝\",\"rank/cjt\",12545]]\n# #     [[\"𧷟\",\"\",\"12\"],      [\"spo\",\"\",\"rank/cjt\",12544]]\n# #     ]\n# #   #.........................................................................................................\n# #   step ( resume ) =>\n# #     yield @_feed_test_data db, probes_idx, write_settings, resume\n# #     prefix        = [ 'pos', 'guide/uchr/has', ]\n# #     input         = HOLLERITH.create_phrasestream db, { prefix, }\n# #     read_settings = { indexed: no, }\n# #     input\n# #       .pipe HOLLERITH.read_sub db, read_settings, ( phrase ) =>\n# #         [ _, glyph, prd, guide, ] = phrase\n# #         prefix                    = [ 'spo', guide, 'factor/strokeclass/wbf', ]\n# #         sub_input                 = HOLLERITH.create_phrasestream db, { prefix, }\n# #         return [ glyph, sub_input, ]\n# #       .pipe HOLLERITH.read_sub db, read_settings, ( xphrase ) =>\n# #         [ glyph, [ _, guide, prd, shapeclass, ] ] = xphrase\n# #         prefix                                    = [ 'spo', guide, 'rank/cjt', ]\n# #         sub_input                                 = HOLLERITH.create_phrasestream db, { prefix, }\n# #         return [ [ glyph, guide, shapeclass, ], sub_input, ]\n# #       .pipe $ ( xphrase, send ) =>\n# #         debug '©quPbg', JSON.stringify xphrase\n# #         count  += +1\n# #         idx    += +1\n# #         T.eq xphrase, matchers[ idx ]\n# #       .pipe D.$on_end ( end ) =>\n# #         T.eq count, matchers.length\n# #         end()\n# #         done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sorting (1)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       'a'\n#       'ab'\n#       'abc'\n#       'abc\\x00'\n#       'abc\\x00a'\n#       'abca'\n#       'abcb'\n#       'abcc'\n#       'abcd'\n#       'abcde'\n#       'abcdef'\n#       'abcdefg' ]\n#     matchers = [\n#       new Buffer [ 0x61, ]\n#       new Buffer [ 0x61, 0x62, ]\n#       new Buffer [ 0x61, 0x62, 0x63, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x00, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x00, 0x61, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x61, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x62, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x63, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x64, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x64, 0x65, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, ]\n#       new Buffer [ 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, ] ]\n#     CND.shuffle probes\n#     for probe in probes\n#       probe_bfr = new Buffer probe, 'utf-8'\n#       yield leveldb.put probe_bfr, '1', resume\n#       probe_bfrs = yield read_all_keys leveldb, resume\n#     probe_bfrs = yield read_all_keys leveldb, resume\n#     # debug '©RXPvv', '\\n' + rpr probe_bfrs\n#     for probe_bfr, probe_idx in probe_bfrs\n#       matcher = matchers[ probe_idx ]\n#       ### TAINT looks like `T.eq buffer1, buffer2` doesn't work---sometimes... ###\n#       # T.eq probe_bfr, matcher\n#       T.ok probe_bfr.equals matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sorting (2)\" ] = ( T, done ) ->\n#   ### This test is here because there seemed to occur some strange ordering issues when\n#   using memdown instead of leveldown ###\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       new Buffer [ 0x00, ]\n#       new Buffer [ 0x01, ]\n#       new Buffer [ 0x02, ]\n#       new Buffer [ 0x03, ]\n#       new Buffer [ 0xf9, ]\n#       new Buffer [ 0xfa, ]\n#       new Buffer [ 0xfb, ]\n#       new Buffer [ 0xfc, ]\n#       new Buffer [ 0xfd, ]\n#       ]\n#     matchers = ( probe for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       yield leveldb.put probe, '1', resume\n#     probe_bfrs = yield read_all_keys leveldb, resume\n#     for probe_bfr, probe_idx in probe_bfrs\n#       matcher = matchers[ probe_idx ]\n#       # debug '©15060', probe_idx, probe_bfr, matcher\n#       ### TAINT looks like `T.eq buffer1, buffer2` doesn't work---sometimes... ###\n#       T.ok probe_bfr.equals matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"H2 codec `encode` throws on anything but a list\" ] = ( T, done ) ->\n#   T.throws \"expected a list, got a text\",         ( -> CODEC.encode 'unaccaptable' )\n#   T.throws \"expected a list, got a number\",       ( -> CODEC.encode 42 )\n#   T.throws \"expected a list, got a boolean\",      ( -> CODEC.encode true )\n#   T.throws \"expected a list, got a boolean\",      ( -> CODEC.encode false )\n#   T.throws \"expected a list, got a jsundefined\",  ( -> CODEC.encode() )\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort texts with H2 codec (1)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       'a'\n#       'ab'\n#       'abc'\n#       'abc\\x00'\n#       'abc\\x00a'\n#       'abca'\n#       'abca\\x00'\n#       'abcb'\n#       'abcc'\n#       'abcd'\n#       'abcde'\n#       'abcdef'\n#       'abcdefg'\n#       ]\n#     matchers = ( [ probe, ] for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       yield leveldb.put ( CODEC.encode [ probe, ] ), '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort texts with H2 codec (2)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       ''\n#       ' '\n#       'a'\n#       'abc'\n#       '一'\n#       '一二'\n#       '一二三'\n#       '三'\n#       '二'\n#       '𠀀'\n#       '𠀀\\x00'\n#       '𠀀a'\n#       '𪜀'\n#       '𫝀'\n#       String.fromCodePoint 0x10ffff\n#       ]\n#     matchers = ( [ probe, ] for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       probe_bfr = CODEC.encode [ probe, ]\n#       yield leveldb.put probe_bfr, '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     # debug '©Fd5iw', probe_bfrs\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort numbers with H2 codec (1)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes_and_descriptions = [\n#       [ -Infinity,               \"-Infinity\"               ]\n#       [ -Number.MAX_VALUE,       \"-Number.MAX_VALUE\"       ]\n#       [ Number.MIN_SAFE_INTEGER, \"Number.MIN_SAFE_INTEGER\" ]\n#       [ -123456789,              \"-123456789\"              ]\n#       [ -3,                      \"-3\"                      ]\n#       [ -2,                      \"-2\"                      ]\n#       [ -1.5,                    \"-1.5\"                    ]\n#       [ -1,                      \"-1\"                      ]\n#       [ -Number.EPSILON,         \"-Number.EPSILON\"         ]\n#       [ -Number.MIN_VALUE,       \"-Number.MIN_VALUE\"       ]\n#       [ 0,                       \"0\"                       ]\n#       [ +Number.MIN_VALUE,       \"+Number.MIN_VALUE\"       ]\n#       [ +Number.EPSILON,         \"+Number.EPSILON\"         ]\n#       [ +1,                      \"+1\"                      ]\n#       [ +1.5,                    \"+1.5\"                    ]\n#       [ +2,                      \"+2\"                      ]\n#       [ +3,                      \"+3\"                      ]\n#       [ +123456789,              \"+123456789\"              ]\n#       [ Number.MAX_SAFE_INTEGER, \"Number.MAX_SAFE_INTEGER\" ]\n#       [ Number.MAX_VALUE,        \"Number.MAX_VALUE\"        ]\n#       [ +Infinity,               \"+Infinity\"               ]\n#       ]\n#     # probes_and_descriptions.sort ( a, b ) ->\n#     #   return +1 if a[ 0 ] > b[ 0 ]\n#     #   return -1 if a[ 0 ] < b[ 0 ]\n#     #   return  0\n#     matchers      = ( [ pad[ 0 ], ] for pad in probes_and_descriptions )\n#     # descriptions  = ( [ pad[ 1 ], ] for pad in probes_and_descriptions )\n#     for pad in probes_and_descriptions\n#       urge pad\n#     CND.shuffle probes_and_descriptions\n#     for [ probe, _, ] in probes_and_descriptions\n#       probe_bfr = CODEC.encode [ probe, ]\n#       yield leveldb.put probe_bfr, '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort mixed values with H2 codec\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       null\n#       false\n#       true\n#       CODEC[ 'sentinels' ][ 'firstdate' ]\n#       new Date 0\n#       new Date 8e11\n#       new Date()\n#       CODEC[ 'sentinels' ][ 'lastdate'  ]\n#       1234\n#       Infinity\n#       ''\n#       '一'\n#       '三'\n#       '二'\n#       '𠀀'\n#       '𠀀\\x00'\n#       String.fromCodePoint 0x10ffff\n#       ]\n#     matchers = ( [ probe, ] for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       debug '©oMXJZ', probe\n#       probe_bfr = CODEC.encode [ probe, ]\n#       yield leveldb.put probe_bfr, '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     # debug '©Fd5iw', probe_bfrs\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort lists of mixed values with H2 codec\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       [ \"\",             '',             ]\n#       [ \"1234\",          1234,           ]\n#       [ \"Infinity\",      Infinity,       ]\n#       [ \"String.fromCodePoint 0x10ffff\", String.fromCodePoint 0x10ffff ]\n#       [ \"false\",         false,          ]\n#       [ \"new Date 0\",    new Date 0,     ]\n#       [ \"new Date 8e11\", new Date 8e11,  ]\n#       [ \"new Date()\",    new Date(),     ]\n#       [ \"null\",          null,           ]\n#       [ \"true\",          true,           ]\n#       [ \"一\",            '一',            ]\n#       [ \"三\",            '三',            ]\n#       [ \"二\",            '二',            ]\n#       [ \"𠀀\",            '𠀀',            ]\n#       [ \"𠀀\\x00\",        '𠀀\\x00',        ]\n#       ]\n#     matchers = ( probe for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       debug '©oMXJZ', probe\n#       probe_bfr = CODEC.encode probe\n#       yield leveldb.put probe_bfr, '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     # debug '©Fd5iw', probe_bfrs\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort routes with values (1)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       [ 'pos', 'strokeorder', '352513553254',          '𤿯', ]\n#       [ 'pos', 'strokeorder', '3525141121',            '𠴦', ]\n#       [ 'pos', 'strokeorder', '35251454',              '𨒡', ]\n#       [ 'pos', 'strokeorder', '3525152',               '邭', ]\n#       [ 'pos', 'strokeorder', '352515251115115113541', '𪚫', ]\n#       [ 'pos', 'strokeorder', '35251525112511511',     '𪚧', ]\n#       [ 'pos', 'strokeorder', '352515251214251214',    '𧑴', ]\n#       [ 'pos', 'strokeorder', '3525153',               '劬', ]\n#       [ 'pos', 'strokeorder', '3525153\\x00',               '劬', ]\n#       [ 'pos', 'strokeorder\\x00', '352513553254',          '𤿯', ]\n#       ]\n#     matchers = ( probe for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       probe_bfr = CODEC.encode probe\n#       yield leveldb.put probe_bfr, '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     # debug '©Fd5iw', probe_bfrs\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"sort routes with values (2)\" ] = ( T, done ) ->\n#   step ( resume ) =>\n#     settings =\n#       db:           leveldown\n#       keyEncoding:  'binary'\n#     leveldb = levelup '/tmp/hollerith2-test', settings\n#     yield clear_leveldb leveldb, resume\n#     probes = [\n#       [ 'a',      null, ]\n#       [ 'a',      false, ]\n#       [ 'a',      true, ]\n#       [ 'a',      new Date(), ]\n#       [ 'a',      -Infinity, ]\n#       [ 'a',      +1234, ]\n#       [ 'a',      +Infinity, ]\n#       [ 'a',      'b', ]\n#       [ 'a',      'b\\x00', ]\n#       [ 'a\\x00',  +1234, ]\n#       [ 'a\\x00',  'b', ]\n#       [ 'aa',     +1234, ]\n#       [ 'aa',     'b', ]\n#       [ 'aa',     'b\\x00', ]\n#       ]\n#     matchers = ( probe for probe in probes )\n#     CND.shuffle probes\n#     for probe in probes\n#       probe_bfr = CODEC.encode probe\n#       yield leveldb.put probe_bfr, '1', resume\n#     probe_bfrs  = yield read_all_keys leveldb, resume\n#     # debug '©Fd5iw', probe_bfrs\n#     probes      = ( CODEC.decode probe_bfr for probe_bfr in probe_bfrs )\n#     show_keys_and_key_bfrs probes, probe_bfrs\n#     for probe, probe_idx in probes\n#       matcher = matchers[ probe_idx ]\n#       T.eq probe, matcher\n#     leveldb.close -> done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read sample data\" ] = ( T, done ) ->\n#   probes_idx  = 2\n#   idx = -1\n#   step ( resume ) =>\n#     debug '©bUJhI', 'XX'\n#     yield @_feed_test_data db, probes_idx, resume\n#     debug '©PRzA5', 'XX'\n#     input = db[ '%self' ].createReadStream()\n#     input\n#       .pipe D.$show()\n#       .pipe $ ( { key, value, }, send ) => send [ key, value, ]\n#       .pipe $ ( [ key, value, ], send ) => send [ key, value, ] unless HOLLERITH._is_meta db, key\n#       .pipe $ ( [ key, value, ], send ) =>\n#         # debug '©RluhF', ( HOLLERITH.CODEC.decode key ), ( JSON.parse value )\n#         send [ key, value, ]\n#       .pipe D.$collect()\n#       .pipe $ ( facets, send ) =>\n#         # debug '©54IKt', facets\n#         help '\\n' + HOLLERITH.DUMP.rpr_of_facets db, facets\n#         buffer = new Buffer JSON.stringify [ '开', '彡' ]\n#         debug '©GJfL6', HOLLERITH.DUMP.rpr_of_buffer db, buffer\n#       .pipe D.$on_end => done()\n#   #.........................................................................................................\n#   return null\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read and write keys with lists\" ] = ( T, done ) ->\n#   probes_idx  = 0\n#   idx         = -1\n#   count       = 0\n#   probes      = [\n#     [ 'a', 1, ]\n#     [ 'a', [], ]\n#     [ 'a', [ 1, ], ]\n#     [ 'a', [ true, ], ]\n#     [ 'a', [ 'x', 'y', 'b', ], ]\n#     [ 'a', [ 120, 1 / 3, ], ]\n#     [ 'a', [ 'x', ], ]\n#     ]\n#   matchers    = ( probe for probe in probes )\n#   #.........................................................................................................\n#   for probe, probe_idx in probes\n#     buffer = HOLLERITH.CODEC.encode probe\n#     result = HOLLERITH.CODEC.decode buffer\n#     T.eq result, matchers[ probe_idx ]\n#   #.........................................................................................................\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"encode keys with list elements\" ] = ( T, done ) ->\n#   probes = [\n#     [ 'foo', 'bar', ]\n#     [ 'foo', [ 'bar', ], ]\n#     [ [], 'bar', ]\n#     [ 'foo', [], ]\n#     [ [ 'foo', ], 'bar', ]\n#     [ [ 42, ], 'bar', ]\n#     [ 'foo', [ 42, ] ]\n#     ]\n#   for probe in probes\n#     T.eq probe, HOLLERITH.CODEC.decode HOLLERITH.CODEC.encode probe\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read and write phrases with unanalyzed lists\" ] = ( T, done ) ->\n#   # ### !!!!!!!!!!!!!!!!!!!!!! ###\n#   # warn \"skipped\"\n#   # return done()\n#   # ### !!!!!!!!!!!!!!!!!!!!!! ###\n#   idx         = -1\n#   count       = 0\n#   #.........................................................................................................\n#   probes = [\n#     [ 'probe#00', 'some-predicate', [], ]\n#     [ 'probe#01', 'some-predicate', [ -1 ], ]\n#     [ 'probe#02', 'some-predicate', [  0 ], ]\n#     [ 'probe#03', 'some-predicate', [  1 ], ]\n#     [ 'probe#04', 'some-predicate', [  2 ], ]\n#     [ 'probe#05', 'some-predicate', [  2, -1, ], ]\n#     [ 'probe#06', 'some-predicate', [  2, 0, ], ]\n#     [ 'probe#07', 'some-predicate', [  2, 1, ], ]\n#     [ 'probe#08', 'some-predicate', [  2, 1, 0 ], ]\n#     [ 'probe#09', 'some-predicate', [  2, 2, ], ]\n#     [ 'probe#10', 'some-predicate', [  2, [ 2, ], ], ]\n#     [ 'probe#11', 'some-predicate', [  3 ], ]\n#     ]\n#   #.........................................................................................................\n#   write_probes = ( handler ) =>\n#     step ( resume ) =>\n#       yield HOLLERITH.clear db, resume\n#       input = D.create_throughstream()\n#       input\n#         # .pipe ( [ sbj, prd, obj, ], send ) =>\n#         #   if prd is 'some-predicate' # always the case in this example\n#         #     obj\n#         .pipe HOLLERITH.$write db, solids: [ 'some-predicate', ]\n#         .pipe D.$on_end =>\n#           urge \"test data written\"\n#           handler()\n#       #.....................................................................................................\n#       input.write probe for probe in probes\n#       input.end()\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     #.......................................................................................................\n#     yield write_probes resume\n#     input = HOLLERITH.create_phrasestream db\n#     debug '©FphJK', input[ '%meta' ]\n#     input\n#       .pipe $ ( phrase, send ) =>\n#         count  += +1\n#         idx    += +1\n#         # debug '©Sc5FG', phrase\n#         # T.eq phrase, matchers[ idx ]\n#       .pipe D.$on_end =>\n#         # T.eq count, matchers.length\n#         done()\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"XXX\" ] = ( T, done ) ->\n# #   warn \"must test for bug with multiple identical entries\"\n# #   probes_idx  = 3\n# #   #.........................................................................................................\n# #   glyphs = [ '丁', '三', '夫', '國', '形', ]\n# #   #.........................................................................................................\n# #   step ( resume ) =>\n# #     yield @_feed_test_data db, probes_idx, resume\n# #     yield show_db_entries resume\n# #     ### TAINT doesn't work: ###\n# #     # prefix    = [ 'pos', 'isa', '*', ]\n# #     prefix    = [ 'pos', 'isa', 'glyph', ]\n# #     input     = HOLLERITH.create_phrasestream db, { prefix, }\n# #     input\n# #       .pipe D.$map ( phrase, handler ) =>\n# #         debug '©gg5Fr', phrase\n# #         [ _, sbj, _, obj, ] = phrase\n# #         debug '©NxZo4', sbj\n# #         sub_prefix  = [ 'spo', obj + ':' + sbj, 'guide', ]\n# #         sub_input   = HOLLERITH.create_phrasestream db, { prefix: sub_prefix, star: '*', }\n# #         sub_input\n# #           .pipe D.$collect()\n# #           .pipe D.$show 'A'\n# #           .pipe $ ( sub_results, send ) =>\n# #             handler null, sub_results\n# #       .pipe D.$show 'B'\n# #       .pipe D.$on_end =>\n# #         # T.eq count, matchers.length\n# #         done()\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"YYY\" ] = ( T, T_done ) ->\n# #   warn \"must test for bug with multiple identical entries\"\n# #   probes_idx  = 3\n# #   #.........................................................................................................\n# #   glyphs = [ '丁', '三', '夫', '國', '形', ]\n# #   #.........................................................................................................\n# #   step ( resume ) =>\n# #     yield @_feed_test_data db, probes_idx, resume\n# #     yield show_db_entries resume\n# #     prefix    = [ 'pos', 'isa', 'glyph', ]\n# #     input     = HOLLERITH.create_phrasestream db, { prefix, }\n# #     input\n# #       .pipe $async ( phrase, done ) =>\n# #         # debug '©PCj9R', phrase\n# #         [ _, sbj, _, obj, ] = phrase\n# #         sub_prefix  = [ 'spo', obj + ':' + sbj, 'guide', ]\n# #         query       = prefix: sub_prefix, star: '*'\n# #         HOLLERITH.read_phrases db, query, ( error, sub_phrases ) =>\n# #           # debug '©VOZ0p', sbj, sub_phrases\n# #           return done.error error if error?\n# #           for sub_phrase, sub_phrase_idx in sub_phrases\n# #             [ _, _, sub_prd, sub_obj, ] = sub_phrase\n# #             sub_phrases[ sub_phrase_idx ] = [ sub_prd, sub_obj, ]\n# #           done [ sbj, sub_phrases..., ]\n# #       .pipe D.$show 'B'\n# #       .pipe D.$on_end =>\n# #         # T.eq count, matchers.length\n# #         T_done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read partial POS phrases\" ] = ( T, done ) ->\n#   # ### !!!!!!!!!!!!!!!!!!!!!! ###\n#   # warn \"skipped\"\n#   # return done()\n#   # ### !!!!!!!!!!!!!!!!!!!!!! ###\n#   probes_idx  = 4\n#   idx         = -1\n#   count       = 0\n#   #.........................................................................................................\n#   matchers = [\n#     [ 'pos', 'guide', 'xxx', '𧷟1' ]\n#     [ 'pos', 'guide/', 'yyy', '𧷟1' ]\n#     [ 'pos', 'guide/lineup/length', 1, '𧷟1', ]\n#     [ 'pos', 'guide/lineup/length', 2, '𧷟2', ]\n#     [ 'pos', 'guide/lineup/length', 3, '𧷟3', ]\n#     [ 'pos', 'guide/lineup/length', 4, '𧷟4', ]\n#     [ 'pos', 'guide/lineup/length', 5, '𧷟', ]\n#     [ 'pos', 'guide/lineup/length', 6, '𧷟6', ]\n#     [ 'pos', 'guide/uchr/has', '八', '𧷟', 0 ]\n#     [ 'pos', 'guide/uchr/has', '刀', '𧷟', 1 ]\n#     [ 'pos', 'guide/uchr/has', '宀', '𧷟', 2 ]\n#     [ 'pos', 'guide/uchr/has', '貝', '𧷟', 4 ]\n#     [ 'pos', 'guide/uchr/has', '', '𧷟', 3 ]\n#     ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     # prefix    = [ 'pos', 'guide', ]\n#     prefix    = [ 'pos', 'guide', ]\n#     input     = HOLLERITH.create_phrasestream db, { prefix, star: '*', }\n#     # input     = HOLLERITH.create_phrasestream db, { prefix, }\n#     debug '©FphJK', input[ '%meta' ]\n#     settings  = { indexed: no, }\n#     input\n#       .pipe $ ( phrase, send ) =>\n#         count  += +1\n#         idx    += +1\n#         debug '©Sc5FG', phrase\n#         T.eq phrase, matchers[ idx ]\n#       .pipe D.$on_end =>\n#         T.eq count, matchers.length\n#         done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read single phrases (1)\" ] = ( T, done ) ->\n#   probes_idx  = 4\n#   matcher = [ 'spo', '𧷟', 'guide/lineup/length', 5 ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     # prefix    = [ 'pos', 'guide', ]\n#     prefix    = [ 'spo', '𧷟', 'guide/lineup/length', ]\n#     query     = { prefix, star: '*', }\n#     input     = HOLLERITH.read_one_phrase db, query, ( error, phrase ) ->\n#       throw error if error?\n#       debug '©61ENl', phrase\n#       T.eq phrase, matcher\n#       done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read single phrases (2)\" ] = ( T, done ) ->\n#   probes_idx  = 4\n#   matcher = [ 'spo', '𧷟', 'guide/lineup/length', 5 ]\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     prefix    = [ 'spo', '𧷟', 'guide/lineup/length', ]\n#     query     = { prefix, star: '*', fallback: 'not to be used', }\n#     input     = HOLLERITH.read_one_phrase db, query, ( error, phrase ) ->\n#       throw error if error?\n#       debug '©61ENl', phrase\n#       T.eq phrase, matcher\n#       done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read single phrases (3)\" ] = ( T, done ) ->\n#   probes_idx  = 4\n#   matcher = \"expected 1 phrase, got 0\"\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     prefix    = [ 'spo', '中', 'guide/lineup/length', ]\n#     query     = { prefix, star: '*', }\n#     input     = HOLLERITH.read_one_phrase db, query, ( error, phrase ) ->\n#       throw new Error \"expected error\" unless error?\n#       T.eq error[ 'message' ], matcher\n#       done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"read single phrases (4)\" ] = ( T, done ) ->\n#   probes_idx  = 4\n#   matcher     = \"this entry is missing\"\n#   #.........................................................................................................\n#   step ( resume ) =>\n#     yield @_feed_test_data db, probes_idx, resume\n#     prefix    = [ 'spo', '中', 'guide/lineup/length', ]\n#     query     = { prefix, star: '*', fallback: matcher, }\n#     input     = HOLLERITH.read_one_phrase db, query, ( error, phrase ) ->\n#       throw error if error?\n#       T.eq phrase, matcher\n#       done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"writing phrases with non-unique keys fails\" ] = ( T, done ) ->\n#   alert \"\"\"test case \"writing phrases with non-unique keys fails\" to be written\"\"\"\n#   done()\n#   # idx         = -1\n#   # count       = 0\n#   # delay = ( handler ) ->\n#   #   setImmediate handler\n#   # #.........................................................................................................\n#   # write_probes = ( handler ) =>\n#   #   step ( resume ) =>\n#   #     yield HOLLERITH.clear db, resume\n#   #     input = D.create_throughstream()\n#   #     input\n#   #       .pipe HOLLERITH.$write db, solids: [ 'some-predicate', ]\n#   #       .pipe D.$on_end =>\n#   #         urge \"test data written\"\n#   #         handler()\n#   #     #.......................................................................................................\n#   #     for idx in [ 0 .. 100 ]\n#   #       probe = [ 'entry', \"foo-#{idx}\", idx, ]\n#   #       yield input.write probe, resume\n#   #       # yield delay resume\n#   #     input.end()\n#   # #.........................................................................................................\n#   # step ( resume ) =>\n#   #   #.......................................................................................................\n#   #   yield write_probes resume\n#   #   input = HOLLERITH.create_phrasestream db\n#   #   debug '©qCbu6', input[ '%meta' ]\n#   #   input\n#   #     .pipe $ ( phrase, send ) =>\n#   #       count  += +1\n#   #       idx    += +1\n#   #       debug '©Sc5FG', phrase\n#   #       # T.eq phrase, matchers[ idx ]\n#   #     .pipe D.$on_end =>\n#   #       # T.eq count, matchers.length\n#   #       done()\n\n# # # #-----------------------------------------------------------------------------------------------------------\n# # # @[ \"_transactions\" ] = ( T, done ) ->\n# # #   levelup = require('levelup')\n# # #   db = levelup('./db', valueEncoding: 'json')\n# # #   require('level-async-transaction') db\n# # #   tx = db.transaction()\n# # #   tx2 = db.transaction()\n# # #   tx.put 'k', 167\n# # #   tx.commit ->\n# # #     tx2.get 'k', (error, value) ->\n# # #       #tx2 increments value\n# # #       tx2.put 'k', value + 1\n# # #       return\n# # #     db.get 'k', (error, data) ->\n# # #       #tx commit: data equals to 167\n# # #       tx2.commit ->\n# # #         db.get 'k', (error, data) ->\n# # #           #tx2 commit: data equals to 168\n# # #           return\n# # #         return\n# # #       return\n# # #     return\n\n\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"ZZZ\" ] = ( T, done ) ->\n# #   log_ticks_id = null\n# #   log_ticks = ->\n# #     debug \"------------------------------------ tick\"\n# #     log_ticks_id = immediately log_ticks\n# #   #---------------------------------------------------------------------------------------------------------\n# #   route             = '/tmp/X-test-db'\n# #   db                = HOLLERITH.new_db route\n# #   input_A           = D.create_throughstream()\n# #   n                 = 1e6\n# #   n                 = 10\n# #   n                 = 1e4\n# #   bloom_error_rate  = 0.1\n# #   entry_count       = 0\n# #   db_request_count  = 0\n# #   t0                = null\n# #   t1                = null\n# #   #.........................................................................................................\n# #   BSON = ( require 'bson' ).BSONPure.BSON\n# #   njs_fs = require 'fs'\n# #   #.........................................................................................................\n# #   BLOEM             = require 'bloem'\n# #   bloem_settings    =\n# #     initial_capacity:   n #/ 10\n# #     scaling:            2\n# #     ratio:              0.1\n# #   #---------------------------------------------------------------------------------------------------------\n# #   show_bloom_info = ( db ) =>\n# #     bloom       = db[ '%bloom' ]\n# #     filters     = bloom[ 'filters' ]\n# #     filter_size = 0\n# #     for filter in filters\n# #       filter_size += filter[ 'filter' ][ 'bitfield' ][ 'buffer' ].length\n# #     whisper \"scalable bloom: filter count: #{filters.length}, filter size: #{ƒ filter_size} bytes\"\n# #   #---------------------------------------------------------------------------------------------------------\n# #   $ensure_unique = ( db ) =>\n# #     return D.$map ( phrase, handler ) =>\n# #       bloom               = db[ '%bloom' ]\n# #       ### >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ###\n# #       [ sbj, prd, obj, ]  = phrase\n# #       key                 = [ 'spo', sbj, prd, ]\n# #       key_bfr             = key.join '|'\n# #       ### >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ###\n# #       bloom_has_key       = bloom.has key_bfr\n# #       bloom.add key_bfr\n# #       return handler null, phrase unless bloom_has_key\n# #       #.....................................................................................................\n# #       HOLLERITH.has db, key, ( error, db_has_key ) =>\n# #         return handler error if error?\n# #         db_request_count += +1\n# #         return handler new Error \"phrase already in DB: #{rpr phrase}\" if db_has_key\n# #         handler null, phrase\n# #   #---------------------------------------------------------------------------------------------------------\n# #   $load_bloom = ( db ) =>\n# #     is_first = yes\n# #     return D.$map ( data, handler ) =>\n# #       unless is_first\n# #         return if data? then handler null, data else handler()\n# #       is_first = no\n# #       #.....................................................................................................\n# #       HOLLERITH._get_meta db, 'bloom', null, ( error, bloom_bfr ) =>\n# #         return send.error error if error?\n# #         if bloom_bfr is null\n# #           warn 'no bloom filter found'\n# #           bloom = new BLOEM.ScalingBloem bloom_error_rate, bloem_settings\n# #         else\n# #           bloom_data = BSON.deserialize bloom_bfr\n# #           ### TAINT see https://github.com/wiedi/node-bloem/issues/5 ###\n# #           for filter in bloom_data[ 'filters' ]\n# #             bitfield              = filter[ 'filter' ][ 'bitfield' ]\n# #             bitfield[ 'buffer' ]  = bitfield[ 'buffer' ][ 'buffer' ]\n# #           bloom = BLOEM.ScalingBloem.destringify bloom_data\n# #         db[ '%bloom' ] = bloom\n# #         return if data? then handler null, data else handler()\n# #   #---------------------------------------------------------------------------------------------------------\n# #   $save_bloom = ( db ) =>\n# #     return D.$on_end ( send, end ) =>\n# #       bloom     = db[ '%bloom' ]\n# #       bloom_bfr = BSON.serialize bloom\n# #       #.....................................................................................................\n# #       HOLLERITH._put_meta db, 'bloom', bloom_bfr, ( error ) =>\n# #         return send.error error if error?\n# #         end()\n# #   #---------------------------------------------------------------------------------------------------------\n# #   input_B = input_A\n# #     .pipe $load_bloom     db\n# #     .pipe $ensure_unique  db\n# #     .pipe $save_bloom     db\n# #     .pipe $ ( data, send ) =>\n# #       entry_count += +1\n# #       whisper entry_count if entry_count % 100000 is 0\n# #       send data\n# #     .pipe HOLLERITH.$write db, batch: 1000\n# #   #-------------------------------------------------------------------------------------------------------\n# #   input_B.on 'end', =>\n# #     t1 = +new Date()\n# #     help \"input_B/end\"\n# #     help \"n:                  #{ƒ n}\"\n# #     help \"DB request count:   #{ƒ db_request_count}\"\n# #     help \"request rate:       #{( db_request_count / n ).toFixed 4}\"\n# #     help \"dt:                 #{ƒ ( t1 - t0 ) / 1000}s\"\n# #     clearImmediate log_ticks_id\n# #     done()\n# #   #-------------------------------------------------------------------------------------------------------\n# #   step ( resume ) =>\n# #     yield HOLLERITH.clear db, resume\n# #     # log_ticks()\n# #     t0 = +new Date()\n# #     for record_idx in [ 0 ... n ]\n# #       sbj     = \"record\"\n# #       prd     = \"nr-#{record_idx}\"\n# #       obj     = record_idx\n# #       phrase  = [ sbj, prd, obj, ]\n# #       # whisper \"input_A.write #{rpr phrase}\"\n# #       yield input_A.write phrase, resume\n# #     #.......................................................................................................\n# #     whisper \"calling input_A.end()\"\n# #     yield input_A.end resume\n\n\n# # #-----------------------------------------------------------------------------------------------------------\n# # @[ \"reminders\" ] = ( T, done ) ->\n# #   alert \"H.$write() must test for repeated keys or implement rewriting of POS entries\"\n# #   done()\n\n\n@ERROR = ( T ) ->\n  T.throws \"x\", ( -> throw new Error \"x\" )\n\n#===========================================================================================================\n# HELPERS\n#-----------------------------------------------------------------------------------------------------------\nshow_keys_and_key_bfrs = ( keys, key_bfrs ) ->\n  f = ( p ) -> ( t for t in ( p.toString 'hex' ).split /(..)/ when t isnt '' ).join ' '\n  #.........................................................................................................\n  columnify_settings =\n    paddingChr: ' '\n  #.........................................................................................................\n  data      = []\n  key_bfrs  = ( f p for p in key_bfrs )\n  for key, idx in keys\n    key_txt = ( rpr key ).replace /\\\\u0000/g, '∇'\n    data.push { 'str': key_txt, 'bfr': key_bfrs[ idx ]}\n  help '\\n' + CND.columnify data, columnify_settings\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nshow_db_entries = ( handler ) ->\n  input = db[ '%self' ].createReadStream()\n  input\n    .pipe D.$show()\n    .pipe $ ( { key, value, }, send ) => send [ key, value, ]\n    .pipe $ ( [ key, value, ], send ) => send [ key, value, ] unless HOLLERITH._is_meta db, key\n    .pipe $ ( [ key, value, ], send ) =>\n      # debug '©RluhF', ( HOLLERITH.CODEC.decode key ), ( JSON.parse value )\n      send [ key, value, ]\n    .pipe D.$collect()\n    .pipe $ ( facets, send ) =>\n      help '\\n' + HOLLERITH.DUMP.rpr_of_facets db, facets\n      # buffer = new Buffer JSON.stringify [ '开', '彡' ]\n      # debug '©GJfL6', HOLLERITH.DUMP.rpr_of_buffer null, buffer\n    .pipe D.$on_end => handler()\n\n#-----------------------------------------------------------------------------------------------------------\nget_new_db_name = ->\n  get_new_db_name.idx += +1\n  return \"/tmp/hollerith2-testdb-#{get_new_db_name.idx}\"\nget_new_db_name.idx = 0\n\n#-----------------------------------------------------------------------------------------------------------\nread_all_keys = ( db, handler ) ->\n  Z = []\n  input = db.createKeyStream()\n  input.on 'end', -> handler null, Z\n  input\n    .pipe $ ( data, send ) => Z.push data\n\n#-----------------------------------------------------------------------------------------------------------\nclear_leveldb = ( leveldb, handler ) ->\n  step ( resume ) =>\n    route = leveldb[ 'location' ]\n    yield leveldb.close resume\n    whisper \"closed LevelDB\"\n    yield leveldown.destroy route, resume\n    whisper \"destroyed LevelDB\"\n    yield leveldb.open resume\n    whisper \"re-opened LevelDB\"\n    # help \"erased and re-opened LevelDB at #{route}\"\n    handler null\n\n#-----------------------------------------------------------------------------------------------------------\n@_main = ( handler ) ->\n  db = HOLLERITH.new_db join __dirname, '..', 'dbs/tests'\n  test @, 'timeout': 2500\n\n############################################################################################################\nunless module.parent?\n  @_main()\n  # @[ \"XXX\" ] null, -> help \"(done)\"\n  # @[ \"YYY\" ] null, -> help \"(done)\"\n  # @[ \"ZZZ\" ] null, -> help \"(done)\"\n\n  # debug '©P9AOR', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'null'       ] ).toString 16\n  # debug '©xxmIp', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'false'      ] ).toString 16\n  # debug '©ZeY26', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'true'       ] ).toString 16\n  # debug '©WgER9', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'date'       ] ).toString 16\n  # debug '©UmpjJ', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'ninfinity'  ] ).toString 16\n  # debug '©Url0K', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'nnumber'    ] ).toString 16\n  # debug '©nFIIi', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'pnumber'    ] ).toString 16\n  # debug '©LZ58R', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'pinfinity'  ] ).toString 16\n  # debug '©MYxda', ( HOLLERITH.CODEC[ 'typemarkers'  ][ 'text'       ] ).toString 16\n\n\n\n\n\n\n\n\n\n\n"]}